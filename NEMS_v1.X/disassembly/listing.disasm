Disassembly Listing for NEMS_v1
Generated From:
/home/saul/MPLABXProjects/NEMS_v1.X/dist/default/debug/NEMS_v1.X.debug.elf
May 12, 2020 6:15:33 PM

---  /tmp/xcXKARPLj.s  ----------------------------------------------------------------------------------
0027  300D     MOVLW 0xD
0BED  0064     CLRWDT
0BEE  0180     CLRF INDF0
0BEF  3101     ADDFSR 0, 1
0BF0  3001     MOVLW 0x1
0BF1  02FE     SUBWF 0x7E, F
0BF2  3000     MOVLW 0x0
0BF3  3BFF     SUBWFB 0x7F, F
0BF4  087F     MOVF 0x7F, W
0BF5  047E     IORWF 0x7E, W
0BF6  1903     BTFSC STATUS, 0x2
0BF8  2BEE     GOTO 0x3EE
0BF7  3400     RETLW 0x0
0028  0084     MOVWF FSR0
0029  3027     MOVLW 0x27
002A  0085     MOVWF FSR0H
002B  30E3     MOVLW 0xE3
002C  00FE     MOVWF 0x7E
002D  3000     MOVLW 0x0
002E  00FF     MOVWF 0x7F
002F  318B     MOVLP 0xB
0032  01F0     CLRF NEMS_pulse_states
0033  01F1     CLRF eusart1RxCount
0034  01F2     CLRF eusart1RxTail
0035  01F3     CLRF eusart1RxHead
0036  01F4     CLRF eusart1TxTail
0037  01F5     CLRF eusart1TxHead
0038  3046     MOVLW 0x46
0039  0084     MOVWF FSR0
003A  3000     MOVLW 0x0
003B  0085     MOVWF FSR0H
003C  3024     MOVLW 0x24
003D  00FE     MOVWF 0x7E
003E  3000     MOVLW 0x0
003F  00FF     MOVWF 0x7F
0040  318B     MOVLP 0xB
0042  107E     BCF 0x7E, 0x0
0043  0140     MOVLB 0x0
0044  318E     MOVLP 0xE
---  /pkg/microchip/xc8/v2.10/pic/sources/c99/pic/__eewrite.c  ------------------------------------------
1:             #include	<xc.h>
2:             
3:             #if	EEPROM_SIZE > 0
4:             
5:             void
6:             eeprom_write(unsigned char addr, unsigned char value)
0DC6  00A1     MOVWF addr
7:             {
8:             	EEPROM_WRITE(addr, value);
0DC7  0150     MOVLB 0x10
0DC8  189E     BTFSC NVMCON1, 0x1
0DC9  2DC7     GOTO 0x5C7
0DCA  171E     BSF NVMCON1, 0x6
0DCB  0140     MOVLB 0x0
0DCC  0821     MOVF addr, W
0DCD  0150     MOVLB 0x10
0DCE  009A     MOVWF NVMADR
0DCF  3070     MOVLW 0x70
0DD0  009B     MOVWF NVMADRH
0DD1  019D     CLRF NVMDATH
0DD2  0140     MOVLB 0x0
0DD3  0820     MOVF __pcstackBANK0, W
0DD4  0150     MOVLB 0x10
0DD5  009C     MOVWF NVMDAT
0DD6  1003     BCF STATUS, 0x0
0DD7  1B8B     BTFSC INTCON, 0x7
0DD8  1403     BSF STATUS, 0x0
0DD9  138B     BCF INTCON, 0x7
0DDA  151E     BSF NVMCON1, 0x2
0DDB  3055     MOVLW 0x55
0DDC  009F     MOVWF NVMCON2
0DDD  30AA     MOVLW 0xAA
0DDE  009F     MOVWF NVMCON2
0DDF  149E     BSF NVMCON1, 0x1
0DE0  189E     BTFSC NVMCON1, 0x1
0DE1  2DE0     GOTO 0x5E0
0DE2  111E     BCF NVMCON1, 0x2
0DE3  1C03     BTFSS STATUS, 0x0
0DE4  0008     RETURN
0DE5  178B     BSF INTCON, 0x7
9:             }
0DE6  0008     RETURN
10:            #endif
11:            
---  /pkg/microchip/xc8/v2.10/pic/sources/c99/pic/__eeread.c  -------------------------------------------
1:             #include	<xc.h>
2:             
3:             #if	EEPROM_SIZE > 0
4:             
5:             unsigned char
6:             eeprom_read(unsigned char addr)
0BF9  00A0     MOVWF 0x820
7:             {
8:             	do
0BFC  0064     CLRWDT
0BFD  0150     MOVLB 0x10
0BFE  189E     BTFSC NVMCON1, 0x1
0BFF  2BFB     GOTO 0x3FB
9:             		CLRWDT();
0BFA  2BFC     GOTO 0x3FC
0BFB  0140     MOVLB 0x0
10:            
11:            #if _EEPROM_INT == _EEREG_INT
12:            	while(EECON1bits.WR);
13:            #elif _EEPROM_INT == _NVMREG_INT
14:            	while (NVMCON1bits.WR);
15:            #else
16:            #error "Unknonwn EEPROM register interface"
17:            #endif
18:            	return EEPROM_READ(addr);
0C00  171E     BSF 0x1E, 0x6
0C01  0140     MOVLB 0x0
0C02  0820     MOVF __pcstackBANK0, W
0C03  0150     MOVLB 0x10
0C04  009A     MOVWF NVMADR
0C05  3070     MOVLW 0x70
0C06  009B     MOVWF NVMADRH
0C07  141E     BSF NVMCON1, 0x0
0C08  081C     MOVF NVMDAT, W
19:            }
0C09  0008     RETURN
20:            #endif
---  /pkg/microchip/xc8/v2.10/pic/sources/c99/common/lwdiv.c  -------------------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             __lwdiv(unsigned int divisor, unsigned int dividend)
0EBD  01AB     CLRF 0x82B
0EBE  01AC     CLRF 0x82C
6:             #else
7:             __lwdiv(unsigned int dividend, unsigned int divisor)
8:             #endif
9:             {
10:            	unsigned int	quotient;
11:            	unsigned char	counter;
12:            
13:            	quotient = 0;
14:            	if(divisor != 0) {
0EBF  0826     MOVF 0x826, W
0EC0  0427     IORWF 0x827, W
0EC1  1903     BTFSC STATUS, 0x2
0EC2  2EEC     GOTO 0x6EC
15:            		counter = 1;
0EC3  01AD     CLRF 0x82D
0EC4  0AAD     INCF 0x82D, F
16:            		while((divisor & 0x8000) == 0) {
0EC5  1BA7     BTFSC 0x827, 0x7
0EC6  2ED1     GOTO 0x6D1
0ED0  2EC5     GOTO 0x6C5
17:            			divisor <<= 1;
0EC7  3001     MOVLW 0x1
0EC8  35A6     LSLF 0x826, F
0EC9  0DA7     RLF 0x827, F
0ECA  0B89     DECFSZ WREG, F
0ECB  2EC8     GOTO 0x6C8
18:            			counter++;
0ECC  3001     MOVLW 0x1
0ECD  00AA     MOVWF 0x82A
0ECE  082A     MOVF 0x82A, W
0ECF  07AD     ADDWF 0x82D, F
19:            		}
20:            		do {
21:            			quotient <<= 1;
0ED1  3001     MOVLW 0x1
0ED2  35AB     LSLF 0x82B, F
0ED3  0DAC     RLF 0x82C, F
0ED4  0B89     DECFSZ WREG, F
0ED5  2ED2     GOTO 0x6D2
22:            			if(divisor <= dividend) {
0ED6  0827     MOVF 0x827, W
0ED7  0229     SUBWF 0x829, W
0ED8  1D03     BTFSS STATUS, 0x2
0ED9  2EDC     GOTO 0x6DC
0EDA  0826     MOVF 0x826, W
0EDB  0228     SUBWF 0x828, W
0EDC  1C03     BTFSS STATUS, 0x0
0EDD  2EE3     GOTO 0x6E3
23:            				dividend -= divisor;
0EDE  0826     MOVF 0x826, W
0EDF  02A8     SUBWF 0x828, F
0EE0  0827     MOVF 0x827, W
0EE1  3BA9     SUBWFB 0x829, F
24:            				quotient |= 1;
0EE2  142B     BSF 0x82B, 0x0
25:            			}
26:            			divisor >>= 1;
0EE3  3001     MOVLW 0x1
0EE4  36A7     LSRF 0x827, F
0EE5  0CA6     RRF 0x826, F
0EE6  0B89     DECFSZ WREG, F
0EE7  2EE4     GOTO 0x6E4
27:            		} while(--counter != 0);
0EE8  3001     MOVLW 0x1
0EE9  02AD     SUBWF 0x82D, F
0EEA  1D03     BTFSS STATUS, 0x2
0EEB  2ED1     GOTO 0x6D1
28:            	}
29:            	return quotient;
0EEC  082C     MOVF 0x82C, W
0EED  00A7     MOVWF 0x827
0EEE  082B     MOVF 0x82B, W
0EEF  00A6     MOVWF 0x826
30:            }
0EF0  0008     RETURN
---  /pkg/microchip/xc8/v2.10/pic/sources/c99/common/lbmod.c  -------------------------------------------
1:             // byte unsigned modulus
2:             
3:             unsigned char
4:             __lbmod(unsigned char dividend, unsigned char divisor)
0DA7  00A3     MOVWF 0x823
5:             {
6:             	unsigned char	rem;
7:             	unsigned char	counter;
8:             
9:             	counter = 8;
0DA8  3008     MOVLW 0x8
0DA9  00A1     MOVWF 0x821
0DAA  0821     MOVF 0x821, W
0DAB  00A4     MOVWF 0x824
10:            	rem = 0;
0DAC  01A5     CLRF 0x825
11:            	do {
12:            		rem = (rem << 1) | (dividend >> 7);
0DAD  0823     MOVF 0x823, W
0DAE  00A1     MOVWF 0x821
0DAF  3007     MOVLW 0x7
0DB0  36A1     LSRF 0x821, F
0DB1  0B89     DECFSZ WREG, F
0DB2  2DB0     GOTO 0x5B0
0DB3  3525     LSLF 0x825, W
0DB4  0421     IORWF 0x821, W
0DB5  00A2     MOVWF 0x822
0DB6  0822     MOVF 0x822, W
0DB7  00A5     MOVWF 0x825
13:            		dividend <<= 1;
0DB8  1003     BCF STATUS, 0x0
0DB9  0DA3     RLF 0x823, F
14:            		if(divisor <= rem)
0DBA  0820     MOVF 0x820, W
0DBB  0225     SUBWF 0x825, W
0DBC  1C03     BTFSS STATUS, 0x0
0DBD  2DC0     GOTO 0x5C0
15:            			rem -= divisor;
0DBE  0820     MOVF 0x820, W
0DBF  02A5     SUBWF 0x825, F
16:            	} while(--counter != 0);
0DC0  3001     MOVLW 0x1
0DC1  02A4     SUBWF 0x824, F
0DC2  1D03     BTFSS STATUS, 0x2
0DC3  2DAD     GOTO 0x5AD
17:            	return rem;
0DC4  0825     MOVF 0x825, W
18:            }
0DC5  0008     RETURN
---  /pkg/microchip/xc8/v2.10/pic/sources/c99/common/awdiv.c  -------------------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             __awdiv(signed int divisor, signed int dividend)
0FAF  01AC     CLRF 0x82C
6:             #else
7:             __awdiv(signed int dividend, signed int divisor)
8:             #endif
9:             {
10:            	signed int	quotient;
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
14:            	if(divisor < 0) {
0FB0  1FA7     BTFSS 0x827, 0x7
0FB1  2FB9     GOTO 0x7B9
15:            		divisor = -divisor;
0FB2  09A6     COMF 0x826, F
0FB3  09A7     COMF 0x827, F
0FB4  0AA6     INCF 0x826, F
0FB5  1903     BTFSC STATUS, 0x2
0FB6  0AA7     INCF 0x827, F
16:            		sign = 1;
0FB7  01AC     CLRF 0x82C
0FB8  0AAC     INCF 0x82C, F
17:            	}
18:            	if(dividend < 0) {
0FB9  1FA9     BTFSS 0x829, 0x7
0FBA  2FC4     GOTO 0x7C4
19:            		dividend = -dividend;
0FBB  09A8     COMF 0x828, F
0FBC  09A9     COMF 0x829, F
0FBD  0AA8     INCF 0x828, F
0FBE  1903     BTFSC STATUS, 0x2
0FBF  0AA9     INCF 0x829, F
20:            		sign ^= 1;
0FC0  3001     MOVLW 0x1
0FC1  00AA     MOVWF 0x82A
0FC2  082A     MOVF 0x82A, W
0FC3  06AC     XORWF 0x82C, F
21:            	}
22:            	quotient = 0;
0FC4  01AD     CLRF 0x82D
0FC5  01AE     CLRF 0x82E
23:            	if(divisor != 0) {
0FC6  0826     MOVF 0x826, W
0FC7  0427     IORWF 0x827, W
0FC8  1903     BTFSC STATUS, 0x2
0FC9  2FF3     GOTO 0x7F3
24:            		counter = 1;
0FCA  01AB     CLRF 0x82B
0FCB  0AAB     INCF 0x82B, F
25:            		while((divisor & 0x8000U) == 0) {
0FCC  1BA7     BTFSC 0x827, 0x7
0FCD  2FD8     GOTO 0x7D8
0FD7  2FCC     GOTO 0x7CC
26:            			divisor <<= 1;
0FCE  3001     MOVLW 0x1
0FCF  35A6     LSLF 0x826, F
0FD0  0DA7     RLF 0x827, F
0FD1  0B89     DECFSZ WREG, F
0FD2  2FCF     GOTO 0x7CF
27:            			counter++;
0FD3  3001     MOVLW 0x1
0FD4  00AA     MOVWF 0x82A
0FD5  082A     MOVF 0x82A, W
0FD6  07AB     ADDWF 0x82B, F
28:            		}
29:            		do {
30:            			quotient <<= 1;
0FD8  3001     MOVLW 0x1
0FD9  35AD     LSLF 0x82D, F
0FDA  0DAE     RLF 0x82E, F
0FDB  0B89     DECFSZ WREG, F
0FDC  2FD9     GOTO 0x7D9
31:            			if((unsigned int)divisor <= (unsigned int)dividend) {
0FDD  0827     MOVF 0x827, W
0FDE  0229     SUBWF 0x829, W
0FDF  1D03     BTFSS STATUS, 0x2
0FE0  2FE3     GOTO 0x7E3
0FE1  0826     MOVF 0x826, W
0FE2  0228     SUBWF 0x828, W
0FE3  1C03     BTFSS STATUS, 0x0
0FE4  2FEA     GOTO 0x7EA
32:            				dividend -= divisor;
0FE5  0826     MOVF 0x826, W
0FE6  02A8     SUBWF 0x828, F
0FE7  0827     MOVF 0x827, W
0FE8  3BA9     SUBWFB 0x829, F
33:            				quotient |= 1;
0FE9  142D     BSF 0x82D, 0x0
34:            			}
35:            			*(unsigned int *)&divisor >>= 1;
0FEA  3001     MOVLW 0x1
0FEB  36A7     LSRF 0x827, F
0FEC  0CA6     RRF 0x826, F
0FED  0B89     DECFSZ WREG, F
0FEE  2FEB     GOTO 0x7EB
36:            		} while(--counter != 0);
0FEF  3001     MOVLW 0x1
0FF0  02AB     SUBWF 0x82B, F
0FF1  1D03     BTFSS STATUS, 0x2
0FF2  2FD8     GOTO 0x7D8
37:            	}
38:            	if(sign)
0FF3  082C     MOVF 0x82C, W
0FF4  1903     BTFSC STATUS, 0x2
0FF5  2FFB     GOTO 0x7FB
39:            		quotient = -quotient;
0FF6  09AD     COMF 0x82D, F
0FF7  09AE     COMF 0x82E, F
0FF8  0AAD     INCF 0x82D, F
0FF9  1903     BTFSC STATUS, 0x2
0FFA  0AAE     INCF 0x82E, F
40:            	return quotient;
0FFB  082E     MOVF 0x82E, W
0FFC  00A7     MOVWF 0x827
0FFD  082D     MOVF 0x82D, W
0FFE  00A6     MOVWF 0x826
41:            }
0FFF  0008     RETURN
---  /pkg/microchip/xc8/v2.10/pic/sources/c99/common/Umul8.c  -------------------------------------------
1:             // 8 x 8 bit multiplication with 8 bit result
2:             
3:             unsigned char
4:             __bmul(unsigned char multiplier, unsigned char multiplicand)
0C0A  00A3     MOVWF 0x823
5:             {
6:             	unsigned char product = 0;
0C0B  01A2     CLRF 0x822
7:             
8:             #if defined(__OPTIMIZE_SPEED__)
9:             
10:            	if(multiplier & 0x01)
11:            		product = (product + multiplicand) & 0xff;
12:            	multiplicand <<= 1;
13:            
14:            	if(multiplier & 0x02)
15:            		product = (product + multiplicand) & 0xff;
16:            	multiplicand <<= 1;
17:            
18:            	if(multiplier & 0x04)
19:            		product = (product + multiplicand) & 0xff;
20:            	multiplicand <<= 1;
21:            
22:            	if(multiplier & 0x08)
23:            		product = (product + multiplicand) & 0xff;
24:            	multiplicand <<= 1;
25:            
26:            	if(multiplier & 0x10)
27:            		product = (product + multiplicand) & 0xff;
28:            	multiplicand <<= 1;
29:            
30:            	if(multiplier & 0x20)
31:            		product = (product + multiplicand) & 0xff;
32:            	multiplicand <<= 1;
33:            
34:            	if(multiplier & 0x40)
35:            		product = (product + multiplicand) & 0xff;
36:            	multiplicand <<= 1;
37:            
38:            	if(multiplier & 0x80)
39:            		product = (product + multiplicand) & 0xff;
40:            
41:            #else
42:            	do {
43:            		if(multiplier & 1)
0C0C  1C23     BTFSS 0x823, 0x0
0C0D  2C12     GOTO 0x412
44:            			product += multiplicand;
0C0E  0820     MOVF 0x820, W
0C0F  00A1     MOVWF 0x821
0C10  0821     MOVF 0x821, W
0C11  07A2     ADDWF 0x822, F
45:            		multiplicand <<= 1;
0C12  1003     BCF STATUS, 0x0
0C13  0DA0     RLF 0x820, F
46:            		multiplier >>= 1;
0C14  1003     BCF STATUS, 0x0
0C15  0CA3     RRF 0x823, F
47:            	} while(multiplier != 0);
0C16  0823     MOVF 0x823, W
0C17  1D03     BTFSS STATUS, 0x2
0C18  2C0C     GOTO 0x40C
48:            
49:            #endif
50:            	return product;
0C19  0822     MOVF 0x822, W
51:            }
0C1A  0008     RETURN
---  /pkg/microchip/xc8/v2.10/pic/sources/c99/common/Umul16.c  ------------------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
0D35  01A4     CLRF 0x824
0D36  01A5     CLRF 0x825
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
40:            
41:            #else
42:            
43:            	product = 0;
44:            	do {
45:            		if(multiplier & 1)
0D37  1C20     BTFSS 0x820, 0x0
0D38  2D3D     GOTO 0x53D
46:            			product += multiplicand;
0D39  0822     MOVF 0x822, W
0D3A  07A4     ADDWF 0x824, F
0D3B  0823     MOVF 0x823, W
0D3C  3DA5     ADDWFC 0x825, F
47:            		multiplicand <<= 1;
0D3D  3001     MOVLW 0x1
0D3E  35A2     LSLF 0x822, F
0D3F  0DA3     RLF 0x823, F
0D40  0B89     DECFSZ WREG, F
0D41  2D3E     GOTO 0x53E
48:            		multiplier >>= 1;
0D42  3001     MOVLW 0x1
0D43  36A1     LSRF 0x821, F
0D44  0CA0     RRF 0x820, F
0D45  0B89     DECFSZ WREG, F
0D46  2D43     GOTO 0x543
49:            	} while(multiplier != 0);
0D47  0820     MOVF 0x820, W
0D48  0421     IORWF 0x821, W
0D49  1D03     BTFSS STATUS, 0x2
0D4A  2D37     GOTO 0x537
50:            
51:            #endif
52:                    return product;
0D4B  0825     MOVF 0x825, W
0D4C  00A1     MOVWF 0x821
0D4D  0824     MOVF 0x824, W
0D4E  00A0     MOVWF 0x820
53:            }
0D4F  0008     RETURN
---  /home/saul/MPLABXProjects/NEMS_v1.X/mcc_generated_files/tmr0.c  ------------------------------------
1:             /**
2:               TMR0 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr0.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR0 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR0.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.0
17:                    Device            :  PIC16LF18426
18:                    Driver Version    :  3.10
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.10 and above
21:                    MPLAB 	          :  MPLAB X 5.35
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr0.h"
53:            
54:            /**
55:              Section: Global Variables Definitions
56:            */
57:            
58:            volatile uint16_t timer0ReloadVal16bit;
59:            
60:            /**
61:              Section: TMR0 APIs
62:            */
63:            
64:            void (*TMR0_InterruptHandler)(void);
65:            
66:            void TMR0_Initialize(void)
0D50  3040     MOVLW 0x40
0D51  014B     MOVLB 0xB
0D52  009F     MOVWF T0CON1
67:            {
68:                // Set TMR0 to the options selected in the User Interface
69:            
70:                // T0CS FOSC/4; T0CKPS 1:1; T0ASYNC synchronised; 
71:                T0CON1 = 0x40;
72:            
73:                // TMR0H 254; 
74:                TMR0H = 0xFE;
0D53  30FE     MOVLW 0xFE
0D54  009D     MOVWF TMR0H
75:            
76:                // TMR0L 128; 
77:                TMR0L = 0x80;
0D55  3080     MOVLW 0x80
0D56  009C     MOVWF TMR0L
78:            
79:                // Load TMR0 value to the 16-bit reload variable
80:                timer0ReloadVal16bit = (TMR0H << 8) | TMR0L;
0D57  081D     MOVF TMR0H, W
0D58  0140     MOVLB 0x0
0D59  00ED     MOVWF 0x6D
0D5A  014B     MOVLB 0xB
0D5B  081C     MOVF TMR0L, W
0D5C  0140     MOVLB 0x0
0D5D  00EC     MOVWF timer0ReloadVal16bit
81:            
82:                // Clear Interrupt flag before enabling the interrupt
83:                PIR0bits.TMR0IF = 0;
0D5E  014E     MOVLB 0xE
0D5F  128C     BCF PIR0, 0x5
84:            
85:                // Enabling TMR0 interrupt.
86:                PIE0bits.TMR0IE = 1;
0D60  1696     BSF PIE0, 0x5
87:            
88:                // Set Default Interrupt Handler
89:                TMR0_SetInterruptHandler(TMR0_DefaultInterruptHandler);
0D61  3003     MOVLW 0x3
0D62  0140     MOVLB 0x0
0D63  00A0     MOVWF __pcstackBANK0
0D64  3000     MOVLW 0x0
0D65  00A1     MOVWF addr
0D66  318B     MOVLP 0xB
0D67  2394     CALL 0x394
90:            
91:                // T0OUTPS 1:1; T0EN enabled; T016BIT 16-bit; 
92:                T0CON0 = 0x90;
0D68  3090     MOVLW 0x90
0D69  014B     MOVLB 0xB
0D6A  009E     MOVWF T0CON0
93:            }
0D6B  0008     RETURN
94:            
95:            void TMR0_StartTimer(void)
0B84  014B     MOVLB 0xB
0B85  179E     BSF T0CON0, 0x7
96:            {
97:                // Start the Timer by writing to TMR0ON bit
98:                T0CON0bits.T0EN = 1;
99:            }
0B86  0008     RETURN
100:           
101:           void TMR0_StopTimer(void)
0B81  014B     MOVLB 0xB
0B82  139E     BCF T0CON0, 0x7
102:           {
103:               // Stop the Timer by writing to TMR0ON bit
104:               T0CON0bits.T0EN = 0;
105:           }
0B83  0008     RETURN
106:           
107:           uint16_t TMR0_ReadTimer(void)
108:           {
109:               uint16_t readVal;
110:               uint8_t readValLow;
111:               uint8_t readValHigh;
112:           
113:               readValLow  = TMR0L;
114:               readValHigh = TMR0H;
115:               readVal  = ((uint16_t)readValHigh << 8) + readValLow;
116:           
117:               return readVal;
118:           }
119:           
120:           void TMR0_WriteTimer(uint16_t timerVal)
121:           {
122:               // Write to the Timer0 register
123:               TMR0H = timerVal >> 8;
124:               TMR0L = (uint8_t) timerVal;
125:           }
126:           
127:           void TMR0_Reload(void)
128:           {
129:               // Write to the Timer0 register
130:               TMR0H = timer0ReloadVal16bit >> 8;
131:               TMR0L = (uint8_t) timer0ReloadVal16bit;
132:           }
133:           
134:           void TMR0_ISR(void)
0C3E  128C     BCF NCO1ACC, 0x5
135:           {
136:               // clear the TMR0 interrupt flag
137:               PIR0bits.TMR0IF = 0;
138:               // Write to the Timer0 register
139:               TMR0H = timer0ReloadVal16bit >> 8;
0C3F  0140     MOVLB 0x0
0C40  086D     MOVF 0x6D, W
0C41  014B     MOVLB 0xB
0C42  009D     MOVWF TMR0H
140:               TMR0L = (uint8_t) timer0ReloadVal16bit;
0C43  0140     MOVLB 0x0
0C44  086C     MOVF timer0ReloadVal16bit, W
0C45  014B     MOVLB 0xB
0C46  009C     MOVWF TMR0L
141:           
142:               if(TMR0_InterruptHandler)
0C47  0140     MOVLB 0x0
0C48  086A     MOVF TMR0_InterruptHandler, W
0C49  046B     IORWF 0x6B, W
0C4A  1903     BTFSC STATUS, 0x2
0C4B  0008     RETURN
143:               {
144:                   TMR0_InterruptHandler();
0C4C  086B     MOVF 0x6B, W
0C4D  008A     MOVWF PCLATH
0C4E  086A     MOVF TMR0_InterruptHandler, W
0C4F  000A     CALLW
0C50  318C     MOVLP 0xC
145:               }
146:           
147:               // add your TMR0 interrupt custom code
148:           }
0C51  0008     RETURN
149:           
150:           
151:           void TMR0_SetInterruptHandler(void (* InterruptHandler)(void)){
0B94  0821     MOVF addr, W
0B95  00EB     MOVWF 0x6B
0B96  0820     MOVF __pcstackBANK0, W
0B97  00EA     MOVWF TMR0_InterruptHandler
152:               TMR0_InterruptHandler = InterruptHandler;
153:           }
0B98  0008     RETURN
154:           
155:           void TMR0_DefaultInterruptHandler(void){
0003  0008     RETURN
156:               // add your TMR0 interrupt custom code
157:               // or set custom function using TMR0_SetInterruptHandler()
158:           }
159:           
160:           /**
161:             End of File
162:           */
---  /home/saul/MPLABXProjects/NEMS_v1.X/mcc_generated_files/pin_manager.c  -----------------------------
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.0
17:                    Device            :  PIC16LF18426
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.10 and above
21:                    MPLAB             :  MPLAB X 5.35
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "pin_manager.h"
50:            
51:            
52:            
53:            
54:            
55:            void PIN_MANAGER_Initialize(void)
0D89  0140     MOVLB 0x0
0D8A  0198     CLRF LATA
56:            {
57:                /**
58:                LATx registers
59:                */
60:                LATA = 0x00;
61:                LATC = 0x00;
0D8B  019A     CLRF LATC
62:            
63:                /**
64:                TRISx registers
65:                */
66:                TRISA = 0x1E;
0D8C  301E     MOVLW 0x1E
0D8D  0092     MOVWF TRISA
67:                TRISC = 0x29;
0D8E  3029     MOVLW 0x29
0D8F  0094     MOVWF TRISC
68:            
69:                /**
70:                ANSELx registers
71:                */
72:                ANSELC = 0x1F;
0D90  301F     MOVLW 0x1F
0D91  017E     MOVLB 0x3E
0D92  00CE     MOVWF ANSELC
73:                ANSELA = 0x37;
0D93  3037     MOVLW 0x37
0D94  00B8     MOVWF ANSELA
74:            
75:                /**
76:                WPUx registers
77:                */
78:                WPUA = 0x00;
0D95  01B9     CLRF WPUA
79:                WPUC = 0x00;
0D96  01CF     CLRF WPUC
80:            
81:                /**
82:                ODx registers
83:                */
84:                ODCONA = 0x00;
0D97  01BA     CLRF ODCONA
85:                ODCONC = 0x00;
0D98  01D0     CLRF ODCONC
86:            
87:                /**
88:                SLRCONx registers
89:                */
90:                SLRCONA = 0x37;
0D99  3037     MOVLW 0x37
0D9A  00BB     MOVWF SLRCONA
91:                SLRCONC = 0x3F;
0D9B  303F     MOVLW 0x3F
0D9C  00D1     MOVWF SLRCONC
92:            
93:                /**
94:                INLVLx registers
95:                */
96:                INLVLA = 0x3F;
0D9D  303F     MOVLW 0x3F
0D9E  00BC     MOVWF INLVLA
97:                INLVLC = 0x3F;
0D9F  303F     MOVLW 0x3F
0DA0  00D2     MOVWF INLVLC
98:            
99:            
100:           
101:           
102:           
103:              
104:               
105:           	
106:               RC4PPS = 0x0F;   //RC4->EUSART1:TX1;    
0DA1  300F     MOVLW 0xF
0DA2  00A4     MOVWF RC4PPS
107:               RX1DTPPS = 0x15;   //RC5->EUSART1:RX1;    
0DA3  3015     MOVLW 0x15
0DA4  017D     MOVLB 0x3D
0DA5  00CB     MOVWF RX1DTPPS
108:           }
0DA6  0008     RETURN
109:             
110:           void PIN_MANAGER_IOC(void)
111:           {   
112:           }
113:           
114:           /**
115:            End of File
116:           */
---  /home/saul/MPLABXProjects/NEMS_v1.X/mcc_generated_files/mcc.c  -------------------------------------
1:             /**
2:               @Generated PIC10 / PIC12 / PIC16 / PIC18 MCUs Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.0
17:                    Device            :  PIC16LF18426
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.10 and above or later
21:                    MPLAB             :  MPLAB X 5.35
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "mcc.h"
48:            
49:            
50:            void SYSTEM_Initialize(void)
0C52  318B     MOVLP 0xB
0C53  23E3     CALL 0x3E3
0C54  318C     MOVLP 0xC
51:            {
52:                PMD_Initialize();
53:                PIN_MANAGER_Initialize();
0C55  318D     MOVLP 0xD
0C56  2589     CALL 0x589
0C57  318C     MOVLP 0xC
54:                OSCILLATOR_Initialize();
0C58  318B     MOVLP 0xB
0C59  23DA     CALL 0x3DA
0C5A  318C     MOVLP 0xC
55:                FVR_Initialize();
0C5B  318B     MOVLP 0xB
0C5C  238B     CALL 0x38B
0C5D  318C     MOVLP 0xC
56:                DAC1_Initialize();
0C5E  318B     MOVLP 0xB
0C5F  2399     CALL 0x399
0C60  318C     MOVLP 0xC
57:                TMR0_Initialize();
0C61  318D     MOVLP 0xD
0C62  2550     CALL 0x550
0C63  318C     MOVLP 0xC
58:                EUSART1_Initialize();
0C64  318F     MOVLP 0xF
0C65  276C     CALL 0x76C
59:            }
0C66  0008     RETURN
60:            
61:            void OSCILLATOR_Initialize(void)
0BDA  3060     MOVLW 0x60
0BDB  0151     MOVLB 0x11
0BDC  008D     MOVWF OSCCON1
62:            {
63:                // NOSC HFINTOSC; NDIV 1; 
64:                OSCCON1 = 0x60;
65:                // CSWHOLD may proceed; SOSCPWR Low power; 
66:                OSCCON3 = 0x00;
0BDD  018F     CLRF OSCCON3
67:                // MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
68:                OSCEN = 0x00;
0BDE  0191     CLRF OSCEN
69:                // HFFRQ 32_MHz; 
70:                OSCFRQ = 0x06;
0BDF  3006     MOVLW 0x6
0BE0  0093     MOVWF OSCFRQ
71:                // HFTUN 0; 
72:                OSCTUNE = 0x00;
0BE1  0192     CLRF OSCTUNE
73:            }
0BE2  0008     RETURN
74:            
75:            void PMD_Initialize(void)
0BE3  014F     MOVLB 0xF
0BE4  0196     CLRF PMD0
76:            {
77:                // CLKRMD CLKR enabled; SYSCMD SYSCLK enabled; FVRMD FVR enabled; IOCMD IOC enabled; NVMMD NVM enabled; 
78:                PMD0 = 0x00;
79:                // TMR0MD TMR0 enabled; TMR1MD TMR1 enabled; TMR4MD TMR4 enabled; TMR5MD TMR5 enabled; TMR2MD TMR2 enabled; TMR3MD TMR3 enabled; TMR6MD TMR6 enabled; 
80:                PMD1 = 0x00;
0BE5  0197     CLRF PMD1
81:                // NCO1MD NCO1 enabled; 
82:                PMD2 = 0x00;
0BE6  0198     CLRF PMD2
83:                // ZCDMD ZCD enabled; CMP1MD CMP1 enabled; ADCMD ADC enabled; CMP2MD CMP2 enabled; DAC1MD DAC1 enabled; 
84:                PMD3 = 0x00;
0BE7  0199     CLRF PMD3
85:                // CCP2MD CCP2 enabled; CCP1MD CCP1 enabled; CCP4MD CCP4 enabled; CCP3MD CCP3 enabled; PWM6MD PWM6 enabled; PWM7MD PWM7 enabled; 
86:                PMD4 = 0x00;
0BE8  019A     CLRF PMD4
87:                // CWG2MD CWG2 enabled; CWG1MD CWG1 enabled; 
88:                PMD5 = 0x00;
0BE9  019B     CLRF PMD5
89:                // U1MD EUSART1 enabled; MSSP1MD MSSP1 enabled; MSSP2MD MSSP2 enabled; 
90:                PMD6 = 0x00;
0BEA  019C     CLRF PMD6
91:                // CLC3MD CLC3 enabled; CLC4MD CLC4 enabled; DSM1MD DSM enabled; SMT1MD SMT1 enabled; CLC1MD CLC1 enabled; CLC2MD CLC2 enabled; 
92:                PMD7 = 0x00;
0BEB  019D     CLRF PMD7
93:            }
0BEC  0008     RETURN
94:            
95:            
96:            /**
97:             End of File
98:            */
---  /home/saul/MPLABXProjects/NEMS_v1.X/mcc_generated_files/interrupt_manager.c  -----------------------
1:             /**
2:               Generated Interrupt Manager Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 interrupt_manager.c
9:             
10:              @Summary:
11:                This is the Interrupt Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for global interrupt handling.
15:                For individual peripheral handlers please see the peripheral driver for
16:                all modules selected in the GUI.
17:                Generation Information :
18:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.0
19:                    Device            :  PIC16LF18426
20:                    Driver Version    :  2.03
21:                The generated drivers are tested against the following:
22:                    Compiler          :  XC8 2.10 and above or later
23:                    MPLAB 	          :  MPLAB X 5.35
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "interrupt_manager.h"
50:            #include "mcc.h"
51:            
52:            void __interrupt() INTERRUPT_InterruptManager (void)
0004  147E     BSF 0x7FE, 0x0
0005  3180     MOVLP 0x0
53:            {
54:                // interrupt handler
55:                if(PIE0bits.TMR0IE == 1 && PIR0bits.TMR0IF == 1)
0006  014E     MOVLB 0xE
0007  1A96     BTFSC PIE0, 0x5
0008  1E8C     BTFSS PIR0, 0x5
0009  280E     GOTO 0xE
56:                {
57:                    TMR0_ISR();
000A  318C     MOVLP 0xC
000B  243E     CALL 0x43E
000C  3180     MOVLP 0x0
58:                }
000D  2823     GOTO 0x23
59:                else if(INTCONbits.PEIE == 1)
000E  1F0B     BTFSS INTCON, 0x6
000F  2823     GOTO 0x23
60:                {
61:                    if(PIE3bits.TX1IE == 1 && PIR3bits.TX1IF == 1)
0010  1A19     BTFSC PIE3, 0x4
0011  1E0F     BTFSS PIR3, 0x4
0012  281A     GOTO 0x1A
62:                    {
63:                        EUSART1_TxDefaultInterruptHandler();
0013  0141     MOVLB 0x1
0014  0829     MOVF 0xA9, W
0015  008A     MOVWF PCLATH
0016  0828     MOVF EUSART1_TxDefaultInterruptHandler, W
0017  000A     CALLW
0018  3180     MOVLP 0x0
64:                    } 
0019  2823     GOTO 0x23
65:                    else if(PIE3bits.RC1IE == 1 && PIR3bits.RC1IF == 1)
001A  1A99     BTFSC ADCNT, 0x5
001B  1E8F     BTFSS ADUTHH, 0x5
001C  2823     GOTO 0x23
66:                    {
67:                        EUSART1_RxDefaultInterruptHandler();
001D  0141     MOVLB 0x1
001E  0827     MOVF 0xA7, W
001F  008A     MOVWF PCLATH
0020  0826     MOVF EUSART1_RxDefaultInterruptHandler, W
0021  000A     CALLW
0022  3180     MOVLP 0x0
68:                    } 
69:                    else
70:                    {
71:                        //Unhandled Interrupt
72:                    }
73:                }      
74:                else
75:                {
76:                    //Unhandled Interrupt
77:                }
78:            }
0023  107E     BCF 0xFE, 0x0
0024  0009     RETFIE
79:            /**
80:             End of File
81:            */
---  /home/saul/MPLABXProjects/NEMS_v1.X/mcc_generated_files/fvr.c  -------------------------------------
1:             /**
2:               FVR Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 fvr.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the FVR driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for FVR.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.0
17:                    Device            :  PIC16LF18426
18:                    Driver Version    :  2.01
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.10 and above
21:                    MPLAB             :  MPLAB X 5.35
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "fvr.h"
53:            
54:            /**
55:              Section: FVR APIs
56:            */
57:            
58:            void FVR_Initialize(void)
0B8B  3084     MOVLW 0x84
0B8C  0152     MOVLB 0x12
0B8D  008C     MOVWF FVRCON
59:            {
60:                // CDAFVR 1x; FVREN enabled; TSRNG Lo_range; ADFVR off; TSEN disabled; 
61:                FVRCON = 0x84;
62:            }
0B8E  0008     RETURN
63:            
64:            bool FVR_IsOutputReady(void)
65:            {
66:                return (FVRCONbits.FVRRDY);
67:            }
68:            /**
69:             End of File
70:            */
71:            
---  /home/saul/MPLABXProjects/NEMS_v1.X/mcc_generated_files/eusart1.c  ---------------------------------
1:             /**
2:               EUSART1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 eusart1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the EUSART1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for EUSART1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.0
17:                    Device            :  PIC16LF18426
18:                    Driver Version    :  2.1.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.10 and above
21:                    MPLAB 	          :  MPLAB X 5.35
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            #include "eusart1.h"
51:            
52:            /**
53:              Section: Macro Declarations
54:            */
55:            
56:            #define EUSART1_TX_BUFFER_SIZE 8
57:            #define EUSART1_RX_BUFFER_SIZE 8
58:            
59:            /**
60:              Section: Global Variables
61:            */
62:            volatile uint8_t eusart1TxHead = 0;
63:            volatile uint8_t eusart1TxTail = 0;
64:            volatile uint8_t eusart1TxBuffer[EUSART1_TX_BUFFER_SIZE];
65:            volatile uint8_t eusart1TxBufferRemaining;
66:            
67:            volatile uint8_t eusart1RxHead = 0;
68:            volatile uint8_t eusart1RxTail = 0;
69:            volatile uint8_t eusart1RxBuffer[EUSART1_RX_BUFFER_SIZE];
70:            volatile eusart1_status_t eusart1RxStatusBuffer[EUSART1_RX_BUFFER_SIZE];
71:            volatile uint8_t eusart1RxCount;
72:            volatile eusart1_status_t eusart1RxLastError;
73:            
74:            /**
75:              Section: EUSART1 APIs
76:            */
77:            void (*EUSART1_TxDefaultInterruptHandler)(void);
78:            void (*EUSART1_RxDefaultInterruptHandler)(void);
79:            
80:            void (*EUSART1_FramingErrorHandler)(void);
81:            void (*EUSART1_OverrunErrorHandler)(void);
82:            void (*EUSART1_ErrorHandler)(void);
83:            
84:            void EUSART1_DefaultFramingErrorHandler(void);
85:            void EUSART1_DefaultOverrunErrorHandler(void);
86:            void EUSART1_DefaultErrorHandler(void);
87:            
88:            void EUSART1_Initialize(void)
0F6C  014E     MOVLB 0xE
0F6D  1299     BCF PIE3, 0x5
89:            {
90:                // disable interrupts before changing states
91:                PIE3bits.RC1IE = 0;
92:                EUSART1_SetRxInterruptHandler(EUSART1_Receive_ISR);
0F6E  3058     MOVLW 0x58
0F6F  0140     MOVLB 0x0
0F70  00A0     MOVWF __pcstackBANK0
0F71  300E     MOVLW 0xE
0F72  00A1     MOVWF addr
0F73  318B     MOVLP 0xB
0F74  23CA     CALL 0x3CA
0F75  318F     MOVLP 0xF
93:                PIE3bits.TX1IE = 0;
0F76  014E     MOVLB 0xE
0F77  1219     BCF PIE3, 0x4
94:                EUSART1_SetTxInterruptHandler(EUSART1_Transmit_ISR);
0F78  306C     MOVLW 0x6C
0F79  0140     MOVLB 0x0
0F7A  00A0     MOVWF __pcstackBANK0
0F7B  300D     MOVLW 0xD
0F7C  00A1     MOVWF addr
0F7D  318B     MOVLP 0xB
0F7E  23D2     CALL 0x3D2
0F7F  318F     MOVLP 0xF
95:                // Set the EUSART1 module to the options selected in the user interface.
96:            
97:                // ABDOVF no_overflow; SCKP Non-Inverted; BRG16 16bit_generator; WUE disabled; ABDEN disabled; 
98:                BAUD1CON = 0x08;
0F80  3008     MOVLW 0x8
0F81  0142     MOVLB 0x2
0F82  009F     MOVWF BAUD1CON
99:            
100:               // SPEN enabled; RX9 8-bit; CREN enabled; ADDEN disabled; SREN disabled; 
101:               RC1STA = 0x90;
0F83  3090     MOVLW 0x90
0F84  009D     MOVWF RC1STA
102:           
103:               // TX9 8-bit; TX9D 0; SENDB sync_break_complete; TXEN enabled; SYNC asynchronous; BRGH hi_speed; CSRC slave; 
104:               TX1STA = 0x24;
0F85  3024     MOVLW 0x24
0F86  009E     MOVWF TX1STA
105:           
106:               // SP1BRGL 68; 
107:               SP1BRGL = 0x44;
0F87  3044     MOVLW 0x44
0F88  009B     MOVWF SP1BRG
108:           
109:               // SP1BRGH 0; 
110:               SP1BRGH = 0x00;
0F89  019C     CLRF SP1BRGH
111:           
112:           
113:               EUSART1_SetFramingErrorHandler(EUSART1_DefaultFramingErrorHandler);
0F8A  3002     MOVLW 0x2
0F8B  0140     MOVLB 0x0
0F8C  00A0     MOVWF __pcstackBANK0
0F8D  3000     MOVLW 0x0
0F8E  00A1     MOVWF addr
0F8F  318B     MOVLP 0xB
0F90  23BA     CALL 0x3BA
0F91  318F     MOVLP 0xF
114:               EUSART1_SetOverrunErrorHandler(EUSART1_DefaultOverrunErrorHandler);
0F92  3087     MOVLW 0x87
0F93  0140     MOVLB 0x0
0F94  00A0     MOVWF __pcstackBANK0
0F95  300B     MOVLW 0xB
0F96  00A1     MOVWF addr
0F97  318B     MOVLP 0xB
0F98  23C2     CALL 0x3C2
0F99  318F     MOVLP 0xF
115:               EUSART1_SetErrorHandler(EUSART1_DefaultErrorHandler);
0F9A  307E     MOVLW 0x7E
0F9B  0140     MOVLB 0x0
0F9C  00A0     MOVWF __pcstackBANK0
0F9D  300B     MOVLW 0xB
0F9E  00A1     MOVWF addr
0F9F  318B     MOVLP 0xB
0FA0  23B2     CALL 0x3B2
116:           
117:               eusart1RxLastError.status = 0;
0FA1  0140     MOVLB 0x0
0FA2  01E0     CLRF eusart1RxLastError
118:           
119:               // initializing the driver state
120:               eusart1TxHead = 0;
0FA3  01F5     CLRF eusart1TxHead
121:               eusart1TxTail = 0;
0FA4  01F4     CLRF eusart1TxTail
122:               eusart1TxBufferRemaining = sizeof(eusart1TxBuffer);
0FA5  3008     MOVLW 0x8
0FA6  00A2     MOVWF product
0FA7  0822     MOVF product, W
0FA8  00EE     MOVWF eusart1TxBufferRemaining
123:           
124:               eusart1RxHead = 0;
0FA9  01F3     CLRF eusart1RxHead
125:               eusart1RxTail = 0;
0FAA  01F2     CLRF eusart1RxTail
126:               eusart1RxCount = 0;
0FAB  01F1     CLRF eusart1RxCount
127:           
128:               // enable receive interrupt
129:               PIE3bits.RC1IE = 1;
0FAC  014E     MOVLB 0xE
0FAD  1699     BSF PIE3, 0x5
130:           }
0FAE  0008     RETURN
131:           
132:           bool EUSART1_is_tx_ready(void)
0BAB  086E     MOVF 0x76E, W
0BAC  1903     BTFSC STATUS, 0x2
0BAD  2BB0     GOTO 0x3B0
0BAE  3001     MOVLW 0x1
0BAF  0008     RETURN
0BB0  3000     MOVLW 0x0
133:           {
134:               return (eusart1TxBufferRemaining ? true : false);
135:           }
0BB1  0008     RETURN
136:           
137:           bool EUSART1_is_rx_ready(void)
0BA4  0871     MOVF 0x771, W
0BA5  1903     BTFSC STATUS, 0x2
0BA6  2BA9     GOTO 0x3A9
0BA7  3001     MOVLW 0x1
0BA8  0008     RETURN
0BA9  3000     MOVLW 0x0
138:           {
139:               return (eusart1RxCount ? true : false);
140:           }
0BAA  0008     RETURN
141:           
142:           bool EUSART1_is_tx_done(void)
143:           {
144:               return TX1STAbits.TRMT;
145:           }
146:           
147:           eusart1_status_t EUSART1_get_last_status(void){
148:               return eusart1RxLastError;
149:           }
150:           
151:           uint8_t EUSART1_Read(void)
0E0A  0871     MOVF 0x771, W
0E0B  1903     BTFSC STATUS, 0x2
0E0C  2E0A     GOTO 0x60A
152:           {
153:               uint8_t readValue  = 0;
154:               
155:               while(0 == eusart1RxCount)
156:               {
157:               }
158:           
159:               eusart1RxLastError = eusart1RxStatusBuffer[eusart1RxTail];
0E0D  0872     MOVF 0x772, W
0E0E  3E46     ADDLW 0x46
0E0F  0086     MOVWF FSR1L
0E10  0187     CLRF FSR1H
0E11  0801     MOVF INDF1, W
0E12  0140     MOVLB 0x0
0E13  00A0     MOVWF __pcstackBANK0
0E14  0820     MOVF __pcstackBANK0, W
0E15  00E0     MOVWF eusart1RxLastError
160:           
161:               readValue = eusart1RxBuffer[eusart1RxTail++];
0E16  0872     MOVF eusart1RxTail, W
0E17  3E4E     ADDLW 0x4E
0E18  0086     MOVWF FSR1
0E19  0187     CLRF FSR1H
0E1A  0801     MOVF INDF1, W
0E1B  00A0     MOVWF __pcstackBANK0
0E1C  0820     MOVF __pcstackBANK0, W
0E1D  00A1     MOVWF addr
0E1E  3001     MOVLW 0x1
0E1F  00A0     MOVWF __pcstackBANK0
0E20  0820     MOVF __pcstackBANK0, W
0E21  07F2     ADDWF eusart1RxTail, F
162:               if(sizeof(eusart1RxBuffer) <= eusart1RxTail)
0E22  3008     MOVLW 0x8
0E23  0272     SUBWF eusart1RxTail, W
0E24  1803     BTFSC STATUS, 0x0
163:               {
164:                   eusart1RxTail = 0;
0E25  01F2     CLRF eusart1RxTail
165:               }
166:               PIE3bits.RC1IE = 0;
0E26  014E     MOVLB 0xE
0E27  1299     BCF PIE3, 0x5
167:               eusart1RxCount--;
0E28  3001     MOVLW 0x1
0E29  02F1     SUBWF 0x771, F
168:               PIE3bits.RC1IE = 1;
0E2A  1699     BSF PIE3, 0x5
169:           
170:               return readValue;
0E2B  0140     MOVLB 0x0
0E2C  0821     MOVF addr, W
171:           }
0E2D  0008     RETURN
172:           
173:           void EUSART1_Write(uint8_t txData)
0DE7  00A1     MOVWF addr
174:           {
175:               while(0 == eusart1TxBufferRemaining)
0DE8  086E     MOVF eusart1TxBufferRemaining, W
0DE9  1903     BTFSC STATUS, 0x2
0DEA  2DE8     GOTO 0x5E8
176:               {
177:               }
178:           
179:               if(0 == PIE3bits.TX1IE)
0DEB  014E     MOVLB 0xE
0DEC  1A19     BTFSC PIE3, 0x4
0DED  2DF3     GOTO 0x5F3
180:               {
181:                   TX1REG = txData;
0DEE  0140     MOVLB 0x0
0DEF  0821     MOVF addr, W
0DF0  0142     MOVLB 0x2
0DF1  009A     MOVWF TX1REG
182:               }
0DF2  2E07     GOTO 0x607
183:               else
0DF3  1219     BCF RC1REG, 0x4
184:               {
185:                   PIE3bits.TX1IE = 0;
186:                   eusart1TxBuffer[eusart1TxHead++] = txData;
0DF4  0140     MOVLB 0x0
0DF5  0821     MOVF addr, W
0DF6  00A0     MOVWF __pcstackBANK0
0DF7  0875     MOVF eusart1TxHead, W
0DF8  3E56     ADDLW 0x56
0DF9  0086     MOVWF FSR1
0DFA  0187     CLRF FSR1H
0DFB  0820     MOVF __pcstackBANK0, W
0DFC  0081     MOVWF INDF1
0DFD  3001     MOVLW 0x1
0DFE  00A0     MOVWF __pcstackBANK0
0DFF  0820     MOVF __pcstackBANK0, W
0E00  07F5     ADDWF eusart1TxHead, F
187:                   if(sizeof(eusart1TxBuffer) <= eusart1TxHead)
0E01  3008     MOVLW 0x8
0E02  0275     SUBWF eusart1TxHead, W
0E03  1803     BTFSC STATUS, 0x0
188:                   {
189:                       eusart1TxHead = 0;
0E04  01F5     CLRF eusart1TxHead
190:                   }
191:                   eusart1TxBufferRemaining--;
0E05  3001     MOVLW 0x1
0E06  02EE     SUBWF eusart1TxBufferRemaining, F
192:               }
193:               PIE3bits.TX1IE = 1;
0E07  014E     MOVLB 0xE
0E08  1619     BSF PIE3, 0x4
194:           }
0E09  0008     RETURN
195:           
196:           
197:           void EUSART1_Transmit_ISR(void)
0D6C  3008     MOVLW 0x8
0D6D  0140     MOVLB 0x0
0D6E  026E     SUBWF eusart1TxBufferRemaining, W
0D6F  1803     BTFSC STATUS, 0x0
0D70  2D86     GOTO 0x586
198:           {
199:           
200:               // add your EUSART1 interrupt custom code
201:               if(sizeof(eusart1TxBuffer) > eusart1TxBufferRemaining)
202:               {
203:                   TX1REG = eusart1TxBuffer[eusart1TxTail++];
0D71  0874     MOVF eusart1TxTail, W
0D72  3E56     ADDLW 0x56
0D73  0086     MOVWF FSR1
0D74  0187     CLRF FSR1H
0D75  0801     MOVF INDF1, W
0D76  0142     MOVLB 0x2
0D77  009A     MOVWF TX1REG
0D78  3001     MOVLW 0x1
0D79  00F6     MOVWF 0x176
0D7A  0876     MOVF 0x176, W
0D7B  07F4     ADDWF 0x174, F
204:                   if(sizeof(eusart1TxBuffer) <= eusart1TxTail)
0D7C  3008     MOVLW 0x8
0D7D  0274     SUBWF 0x174, W
0D7E  1803     BTFSC STATUS, 0x0
205:                   {
206:                       eusart1TxTail = 0;
0D7F  01F4     CLRF 0x174
207:                   }
208:                   eusart1TxBufferRemaining++;
0D80  3001     MOVLW 0x1
0D81  00F6     MOVWF 0x176
0D82  0876     MOVF 0x176, W
0D83  0140     MOVLB 0x0
0D84  07EE     ADDWF eusart1TxBufferRemaining, F
209:               }
0D85  0008     RETURN
210:               else
0D86  014E     MOVLB 0xE
0D87  1219     BCF PIE3, 0x4
211:               {
212:                   PIE3bits.TX1IE = 0;
213:               }
214:           }
0D88  0008     RETURN
215:           
216:           void EUSART1_Receive_ISR(void)
0E58  0873     MOVF 0x773, W
0E59  3E46     ADDLW 0x46
0E5A  0086     MOVWF FSR1L
0E5B  0187     CLRF FSR1H
0E5C  0181     CLRF INDF1
217:           {
218:               
219:               eusart1RxStatusBuffer[eusart1RxHead].status = 0;
220:           
221:               if(RC1STAbits.FERR){
0E5D  0142     MOVLB 0x2
0E5E  1D1D     BTFSS RC1STA, 0x2
0E5F  2E6B     GOTO 0x66B
222:                   eusart1RxStatusBuffer[eusart1RxHead].ferr = 1;
0E60  0873     MOVF 0x173, W
0E61  3E46     ADDLW 0x46
0E62  0086     MOVWF FSR1L
0E63  0187     CLRF FSR1H
0E64  1481     BSF INDF1, 0x1
223:                   EUSART1_FramingErrorHandler();
0E65  0141     MOVLB 0x1
0E66  0825     MOVF 0xA5, W
0E67  008A     MOVWF PCLATH
0E68  0824     MOVF EUSART1_FramingErrorHandler, W
0E69  000A     CALLW
0E6A  318E     MOVLP 0xE
224:               }
225:           
226:               if(RC1STAbits.OERR){
0E6B  0142     MOVLB 0x2
0E6C  1C9D     BTFSS RC1STA, 0x1
0E6D  2E79     GOTO 0x679
227:                   eusart1RxStatusBuffer[eusart1RxHead].oerr = 1;
0E6E  0873     MOVF 0x173, W
0E6F  3E46     ADDLW 0x46
0E70  0086     MOVWF FSR1L
0E71  0187     CLRF FSR1H
0E72  1501     BSF INDF1, 0x2
228:                   EUSART1_OverrunErrorHandler();
0E73  0141     MOVLB 0x1
0E74  0823     MOVF 0xA3, W
0E75  008A     MOVWF PCLATH
0E76  0822     MOVF EUSART1_OverrunErrorHandler, W
0E77  000A     CALLW
0E78  318E     MOVLP 0xE
229:               }
230:               
231:               if(eusart1RxStatusBuffer[eusart1RxHead].status){
0E79  0873     MOVF 0xF3, W
0E7A  3E46     ADDLW 0x46
0E7B  0086     MOVWF FSR1L
0E7C  0187     CLRF FSR1H
0E7D  0801     MOVF INDF1, W
0E7E  1903     BTFSC STATUS, 0x2
0E7F  2E87     GOTO 0x687
232:                   EUSART1_ErrorHandler();
0E80  0141     MOVLB 0x1
0E81  0821     MOVF 0xA1, W
0E82  008A     MOVWF PCLATH
0E83  0820     MOVF EUSART1_ErrorHandler, W
0E84  000A     CALLW
0E85  318E     MOVLP 0xE
233:               } else {
0E86  0008     RETURN
234:                   EUSART1_RxDataHandler();
0E87  318C     MOVLP 0xC
0E88  2467     CALL 0x467
235:               }
236:               
237:               // or set custom function using EUSART1_SetRxInterruptHandler()
238:           }
0E89  0008     RETURN
239:           
240:           void EUSART1_RxDataHandler(void){
0C67  0142     MOVLB 0x2
0C68  0819     MOVF RC1REG, W
0C69  00F6     MOVWF 0x176
0C6A  0873     MOVF 0x173, W
0C6B  3E4E     ADDLW 0x4E
0C6C  0086     MOVWF FSR1L
0C6D  0187     CLRF FSR1H
0C6E  0876     MOVF 0x176, W
0C6F  0081     MOVWF INDF1
0C70  3001     MOVLW 0x1
0C71  00F6     MOVWF 0x176
0C72  0876     MOVF 0x176, W
0C73  07F3     ADDWF 0x173, F
241:               // use this default receive interrupt handler code
242:               eusart1RxBuffer[eusart1RxHead++] = RC1REG;
243:               if(sizeof(eusart1RxBuffer) <= eusart1RxHead)
0C74  3008     MOVLW 0x8
0C75  0273     SUBWF 0x173, W
0C76  1803     BTFSC STATUS, 0x0
244:               {
245:                   eusart1RxHead = 0;
0C77  01F3     CLRF 0x173
246:               }
247:               eusart1RxCount++;
0C78  3001     MOVLW 0x1
0C79  00F6     MOVWF 0x176
0C7A  0876     MOVF 0x176, W
0C7B  07F1     ADDWF 0x171, F
248:           }
0C7C  0008     RETURN
249:           
250:           void EUSART1_DefaultFramingErrorHandler(void){}
0002  0008     RETURN
251:           
252:           void EUSART1_DefaultOverrunErrorHandler(void){
0B87  0142     MOVLB 0x2
0B88  121D     BCF RC1STA, 0x4
253:               // EUSART1 error - restart
254:           
255:               RC1STAbits.CREN = 0;
256:               RC1STAbits.CREN = 1;
0B89  161D     BSF RC1STA, 0x4
257:           
258:           }
0B8A  0008     RETURN
259:           
260:           void EUSART1_DefaultErrorHandler(void){
0B7E  318C     MOVLP 0xC
0B7F  2467     CALL 0x467
261:               EUSART1_RxDataHandler();
262:           }
0B80  0008     RETURN
263:           
264:           void EUSART1_SetFramingErrorHandler(void (* interruptHandler)(void)){
0BBA  0821     MOVF 0x121, W
0BBB  0141     MOVLB 0x1
0BBC  00A5     MOVWF 0xA5
0BBD  0140     MOVLB 0x0
0BBE  0820     MOVF __pcstackBANK0, W
0BBF  0141     MOVLB 0x1
0BC0  00A4     MOVWF EUSART1_FramingErrorHandler
265:               EUSART1_FramingErrorHandler = interruptHandler;
266:           }
0BC1  0008     RETURN
267:           
268:           void EUSART1_SetOverrunErrorHandler(void (* interruptHandler)(void)){
0BC2  0821     MOVF 0xA1, W
0BC3  0141     MOVLB 0x1
0BC4  00A3     MOVWF 0xA3
0BC5  0140     MOVLB 0x0
0BC6  0820     MOVF __pcstackBANK0, W
0BC7  0141     MOVLB 0x1
0BC8  00A2     MOVWF EUSART1_OverrunErrorHandler
269:               EUSART1_OverrunErrorHandler = interruptHandler;
270:           }
0BC9  0008     RETURN
271:           
272:           void EUSART1_SetErrorHandler(void (* interruptHandler)(void)){
0BB2  0821     MOVF 0xA1, W
0BB3  0141     MOVLB 0x1
0BB4  00A1     MOVWF 0xA1
0BB5  0140     MOVLB 0x0
0BB6  0820     MOVF __pcstackBANK0, W
0BB7  0141     MOVLB 0x1
0BB8  00A0     MOVWF EUSART1_ErrorHandler
273:               EUSART1_ErrorHandler = interruptHandler;
274:           }
0BB9  0008     RETURN
275:           
276:           void EUSART1_SetTxInterruptHandler(void (* interruptHandler)(void)){
0BD2  0821     MOVF 0xA1, W
0BD3  0141     MOVLB 0x1
0BD4  00A9     MOVWF 0xA9
0BD5  0140     MOVLB 0x0
0BD6  0820     MOVF __pcstackBANK0, W
0BD7  0141     MOVLB 0x1
0BD8  00A8     MOVWF EUSART1_TxDefaultInterruptHandler
277:               EUSART1_TxDefaultInterruptHandler = interruptHandler;
278:           }
0BD9  0008     RETURN
279:           
280:           void EUSART1_SetRxInterruptHandler(void (* interruptHandler)(void)){
0BCA  0821     MOVF 0xA1, W
0BCB  0141     MOVLB 0x1
0BCC  00A7     MOVWF 0xA7
0BCD  0140     MOVLB 0x0
0BCE  0820     MOVF __pcstackBANK0, W
0BCF  0141     MOVLB 0x1
0BD0  00A6     MOVWF EUSART1_RxDefaultInterruptHandler
281:               EUSART1_RxDefaultInterruptHandler = interruptHandler;
282:           }
0BD1  0008     RETURN
283:           /**
284:             End of File
285:           */
---  /home/saul/MPLABXProjects/NEMS_v1.X/mcc_generated_files/dac1.c  ------------------------------------
1:             /**
2:               DAC1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 dac1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the DAC1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for DAC1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.0
17:                    Device            :  PIC16LF18426
18:                    Driver Version    :  2.10
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.10 and above
21:                    MPLAB 	          :  MPLAB X 5.35
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "dac1.h"
53:            
54:            /**
55:              Section: DAC1 APIs
56:            */
57:            
58:            void DAC1_Initialize(void)
0B99  30A8     MOVLW 0xA8
0B9A  008E     MOVWF ADUTH
59:            {
60:                // DAC1OE1 enabled; DAC1EN enabled; NSS VSS; PSS FVR_buf2; 
61:                DAC1CON0 = 0xA8;
62:                // DAC1R 31; 
63:                DAC1CON1 = 0x1F;
0B9B  301F     MOVLW 0x1F
0B9C  008F     MOVWF ADUTHH
64:            }
0B9D  0008     RETURN
65:            
66:            void DAC1_SetOutput(uint8_t inputData)
0B8F  00F6     MOVWF 0xF6
0B9E  0140     MOVLB 0x0
0B9F  00A0     MOVWF __pcstackBANK0
67:            {
68:                DAC1CON1  = inputData;
0B90  0876     MOVF __pcstackCOMMON, W
0B91  0152     MOVLB 0x12
0B92  008F     MOVWF DAC1CON1
0BA0  0820     MOVF 0x920, W
0BA1  0152     MOVLB 0x12
0BA2  008F     MOVWF DAC1CON1
69:            }
0B93  0008     RETURN
0BA3  0008     RETURN
70:            
71:            uint8_t DAC1_GetOutput(void)
72:            {
73:                return DAC1CON1;
74:            }
75:            /**
76:             End of File
77:            */
---  /home/saul/MPLABXProjects/NEMS_v1.X/main.c  --------------------------------------------------------
1:             /**
2:               Generated Main Source File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 main.c
9:             
10:              Summary:
11:                This is the main file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.0
17:                    Device            :  PIC16LF18426
18:                    Driver Version    :  2.00
19:            */
20:            
21:            /*
22:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
23:                
24:                Subject to your compliance with these terms, you may use Microchip software and any 
25:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
26:                license terms applicable to your use of third party software (including open source software) that 
27:                may accompany Microchip software.
28:                
29:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
30:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
31:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
32:                FOR A PARTICULAR PURPOSE.
33:                
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
37:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
38:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
39:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
40:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
41:                SOFTWARE.
42:            */
43:            
44:            #include "mcc_generated_files/mcc.h"
45:            
46:            #include "NEMS.h"
47:            #include "comm.h"
48:            
49:            /*
50:                                     Main application
51:             */
52:            
53:            
54:            void main(void)
0EF1  318C     MOVLP 0xC
0EF2  2452     CALL 0x452
0EF3  318E     MOVLP 0xE
55:            {
56:                    
57:                // initialize the device
58:                SYSTEM_Initialize();
59:                NEMS_initialize();    
0EF4  318E     MOVLP 0xE
0EF5  268A     CALL 0x68A
0EF6  318E     MOVLP 0xE
60:            
61:                // When using interrupts, you need to set the Global and Peripheral Interrupt Enable bits
62:                // Use the following macros to:
63:            
64:                // Enable the Global Interrupts
65:                INTERRUPT_GlobalInterruptEnable();
0EF7  178B     BSF INTCON, 0x7
66:            
67:                // Enable the Peripheral Interrupts
68:                INTERRUPT_PeripheralInterruptEnable();
0EF8  170B     BSF INTCON, 0x6
69:            
70:                // Disable the Global Interrupts
71:                //INTERRUPT_GlobalInterruptDisable();
72:            
73:                // Disable the Peripheral Interrupts
74:                //INTERRUPT_PeripheralInterruptDisable();
75:                
76:                 // Add your application code
77:                
78:                
79:                LED_SetHigh();
0EF9  0140     MOVLB 0x0
0EFA  1698     BSF LATA, 0x5
80:                __delay_ms(200);
0EFB  3009     MOVLW 0x9
0EFC  0141     MOVLB 0x1
0EFD  00AB     MOVWF 0xAB
0EFE  301E     MOVLW 0x1E
0EFF  00AA     MOVWF __pcstackBANK1
0F00  30E4     MOVLW 0xE4
0F01  0B89     DECFSZ WREG, F
0F02  2F01     GOTO 0x701
0F03  0BAA     DECFSZ __pcstackBANK1, F
0F04  2F01     GOTO 0x701
0F05  0BAB     DECFSZ 0xAB, F
0F06  2F01     GOTO 0x701
0F07  0000     NOP
81:                LED_SetLow();
0F08  0140     MOVLB 0x0
0F09  1298     BCF LATA, 0x5
82:                
83:                //ONLY FOR TIMING TEST, DELETE THIS
84:                NEMS_recalculate_program();
0F0A  3183     MOVLP 0x3
0F0B  2322     CALL 0x322
0F0C  318E     MOVLP 0xE
85:                NEMS_start_program();
0F0D  318C     MOVLP 0xC
0F0E  242C     CALL 0x42C
0F0F  318E     MOVLP 0xE
86:                
0F10  3180     MOVLP 0x0
0F11  2046     CALL 0x46
0F12  318E     MOVLP 0xE
87:                while (1) {
0F13  1698     BSF LATA, 0x5
88:                    NEMS_timer();
0F14  3009     MOVLW 0x9
0F15  0141     MOVLB 0x1
0F16  00AB     MOVWF 0xAB
0F17  301E     MOVLW 0x1E
0F18  00AA     MOVWF __pcstackBANK1
0F19  30E4     MOVLW 0xE4
0F1A  0B89     DECFSZ WREG, F
0F1B  2F1A     GOTO 0x71A
0F1C  0BAA     DECFSZ __pcstackBANK1, F
0F1D  2F1A     GOTO 0x71A
0F1E  0BAB     DECFSZ 0xAB, F
0F1F  2F1A     GOTO 0x71A
0F20  0000     NOP
89:                    LED_SetHigh();
0F21  0140     MOVLB 0x0
0F22  1298     BCF LATA, 0x5
90:                    __delay_ms(200);
91:                    LED_SetLow();
92:                }
93:                //ONLY FOR TIMING TEST, DELETE THIS
0F23  318B     MOVLP 0xB
0F24  23A4     CALL 0x3A4
0F25  318E     MOVLP 0xE
0F26  3A00     XORLW 0x0
0F27  1903     BTFSC STATUS, 0x2
0F28  2F23     GOTO 0x723
94:               
0F29  3187     MOVLP 0x7
0F2A  2779     CALL 0x779
0F2B  318E     MOVLP 0xE
0F2C  2F23     GOTO 0x723
95:                while (1)  {
96:                    if(EUSART1_is_rx_ready()) {
97:                        NEMS_message_handler();            
98:                    }       
99:                }
100:           }
101:           /**
102:            End of File
103:           */
---  /home/saul/MPLABXProjects/NEMS_v1.X/comm.c  --------------------------------------------------------
1:             #include "comm.h"
2:             #include "mcc_generated_files/mcc.h"
3:             
4:             
5:             void _puts(char *pt)
0E2E  01A7     CLRF index
6:             {
7:                 unsigned char index;
8:                 index = 0;
9:                 while(pt[index]) {
0E2F  0823     MOVF dividend, W
0E30  00A5     MOVWF rem
0E31  0822     MOVF product, W
0E32  00A4     MOVWF counter
0E33  0827     MOVF index, W
0E34  0724     ADDWF counter, W
0E35  0084     MOVWF FSR0
0E36  0825     MOVF rem, W
0E37  1803     BTFSC STATUS, 0x0
0E38  0A25     INCF rem, W
0E39  0085     MOVWF FSR0H
0E3A  0012     MOVIW FSR0++
0E3B  1903     BTFSC STATUS, 0x2
0E3C  0008     RETURN
0E57  2E2F     GOTO 0x62F
10:                    while(!EUSART1_is_tx_ready());
0E3D  318B     MOVLP 0xB
0E3E  23AB     CALL 0x3AB
0E3F  318E     MOVLP 0xE
0E40  3A00     XORLW 0x0
0E41  1903     BTFSC STATUS, 0x2
0E42  2E3D     GOTO 0x63D
11:                    EUSART1_Write(pt[index++]);        
0E43  0823     MOVF dividend, W
0E44  00A5     MOVWF rem
0E45  0822     MOVF product, W
0E46  00A4     MOVWF counter
0E47  0827     MOVF index, W
0E48  0724     ADDWF counter, W
0E49  0084     MOVWF FSR0
0E4A  0825     MOVF rem, W
0E4B  1803     BTFSC STATUS, 0x0
0E4C  0A25     INCF rem, W
0E4D  0085     MOVWF FSR0H
0E4E  0800     MOVF INDF0, W
0E4F  318D     MOVLP 0xD
0E50  25E7     CALL 0x5E7
0E51  318E     MOVLP 0xE
0E52  3001     MOVLW 0x1
0E53  0140     MOVLB 0x0
0E54  00A4     MOVWF counter
0E55  0824     MOVF counter, W
0E56  07A7     ADDWF index, F
0E57  2E2F     GOTO 0x62F
12:                }
13:            }
14:            
15:            void write(unsigned char *pt, unsigned char lenght)
16:            {
17:                unsigned char i;
18:                
19:                for (i=0; i<lenght; i++) {
20:                    while(!EUSART1_is_tx_ready());
21:                    EUSART1_Write(pt[i]); 
22:                }    
23:            }
24:            
25:            void _sprintf_u16b(char *mess, unsigned short val)
26:            {
27:               // Converts ushort to a fixed point string with a range 0.000 - 9.999
28:               // Note that val is expressed in 1e-3 (milli-X)
29:                
30:              unsigned short aux;   
31:              
32:              aux = val%10;
33:              val /= 10;  
34:                
35:              mess[5] = 0x00;
36:                
37:              mess[4] = (unsigned char)aux+'0';
38:                
39:              aux = val%10;
40:              val /= 10;
41:                
42:              mess[3] = (unsigned char)aux+'0';
43:                
44:              aux = val%10;
45:              val /= 10;
46:                
47:              mess[2] = (unsigned char)aux+'0';
48:              mess[1] = '.';
49:              mess[0] = (unsigned char)val+'0';  
50:            }
51:            
52:            void _sprintf_u8b(char* mess, unsigned char val)
05FE  00B7     MOVWF mess
53:            {
54:                // Converts uchar to a string
55:                unsigned char aux;
56:                unsigned char buf[3];
57:                
58:                aux = val%10;
05FF  300A     MOVLW 0xA
0600  00B0     MOVWF 0x30
0601  0830     MOVF 0x30, W
0602  00A0     MOVWF __pcstackBANK0
0603  082F     MOVF val, W
0604  318D     MOVLP 0xD
0605  25A7     CALL 0x5A7
0606  3185     MOVLP 0x5
0607  00B1     MOVWF 0x31
0608  0831     MOVF 0x31, W
0609  00B3     MOVWF aux
59:                val /=10;
060A  300A     MOVLW 0xA
060B  00A6     MOVWF divisor
060C  3000     MOVLW 0x0
060D  00A7     MOVWF index
060E  082F     MOVF val, W
060F  00B0     MOVWF 0x30
0610  01B1     CLRF 0x31
0611  0830     MOVF 0x30, W
0612  00A8     MOVWF dividend
0613  0831     MOVF 0x31, W
0614  00A9     MOVWF addr
0615  318F     MOVLP 0xF
0616  27AF     CALL 0x7AF
0617  3185     MOVLP 0x5
0618  0826     MOVF divisor, W
0619  00B2     MOVWF 0x32
061A  0832     MOVF 0x32, W
061B  00AF     MOVWF val
60:                
61:                buf[2] = aux;
061C  0833     MOVF aux, W
061D  00B0     MOVWF 0x30
061E  0830     MOVF 0x30, W
061F  00B6     MOVWF 0x36
62:                
63:                aux = val%10;
0620  300A     MOVLW 0xA
0621  00B0     MOVWF 0x30
0622  0830     MOVF 0x30, W
0623  00A0     MOVWF __pcstackBANK0
0624  082F     MOVF val, W
0625  318D     MOVLP 0xD
0626  25A7     CALL 0x5A7
0627  3185     MOVLP 0x5
0628  00B1     MOVWF 0x31
0629  0831     MOVF 0x31, W
062A  00B3     MOVWF aux
64:                val /=10;
062B  300A     MOVLW 0xA
062C  00A6     MOVWF divisor
062D  3000     MOVLW 0x0
062E  00A7     MOVWF index
062F  082F     MOVF val, W
0630  00B0     MOVWF 0x30
0631  01B1     CLRF 0x31
0632  0830     MOVF 0x30, W
0633  00A8     MOVWF dividend
0634  0831     MOVF 0x31, W
0635  00A9     MOVWF addr
0636  318F     MOVLP 0xF
0637  27AF     CALL 0x7AF
0638  3185     MOVLP 0x5
0639  0826     MOVF divisor, W
063A  00B2     MOVWF 0x32
063B  0832     MOVF 0x32, W
063C  00AF     MOVWF val
65:                
66:                buf[1] = aux;    
063D  0833     MOVF aux, W
063E  00B0     MOVWF 0x30
063F  0830     MOVF 0x30, W
0640  00B5     MOVWF 0x35
67:                buf[0] = val;
0641  082F     MOVF val, W
0642  00B0     MOVWF 0x30
0643  0830     MOVF 0x30, W
0644  00B4     MOVWF buf
68:                
69:                if (buf[0] != 0) { // 3 digit number
0645  0834     MOVF buf, W
0646  1903     BTFSC STATUS, 0x2
0647  2E67     GOTO 0x667
70:                    mess[0] = buf[0] + '0';
0648  0834     MOVF buf, W
0649  3E30     ADDLW 0x30
064A  00B0     MOVWF 0x30
064B  0837     MOVF mess, W
064C  0086     MOVWF FSR1
064D  0187     CLRF FSR1H
064E  0830     MOVF 0x30, W
064F  0081     MOVWF INDF1
71:                    mess[1] = buf[1] + '0';
0650  0835     MOVF 0x35, W
0651  3E30     ADDLW 0x30
0652  00B0     MOVWF 0x30
0653  0A37     INCF mess, W
0654  0086     MOVWF FSR1
0655  0187     CLRF FSR1H
0656  0830     MOVF 0x30, W
0657  0081     MOVWF INDF1
72:                    mess[2] = buf[2] + '0';
0658  0836     MOVF 0x36, W
0659  3E30     ADDLW 0x30
065A  00B0     MOVWF 0x30
065B  0837     MOVF mess, W
065C  3E02     ADDLW 0x2
065D  0086     MOVWF FSR1
065E  0187     CLRF FSR1H
065F  0830     MOVF 0x30, W
0660  0081     MOVWF INDF1
73:                    mess[3] = 0x00;
0661  0837     MOVF mess, W
0662  3E03     ADDLW 0x3
0663  0086     MOVWF FSR1
0664  0187     CLRF FSR1H
0665  0181     CLRF INDF1
0666  0008     RETURN
74:                    return;
75:                    
76:                } else if (buf[1] != 0) { // 2 digit number
0667  0835     MOVF 0x35, W
0668  1903     BTFSC STATUS, 0x2
0669  2E80     GOTO 0x680
77:                    mess[0] = buf[1] + '0';
066A  0835     MOVF 0x35, W
066B  3E30     ADDLW 0x30
066C  00B0     MOVWF 0x30
066D  0837     MOVF mess, W
066E  0086     MOVWF FSR1
066F  0187     CLRF FSR1H
0670  0830     MOVF 0x30, W
0671  0081     MOVWF INDF1
78:                    mess[1] = buf[2] + '0';
0672  0836     MOVF 0x36, W
0673  3E30     ADDLW 0x30
0674  00B0     MOVWF 0x30
0675  0A37     INCF mess, W
0676  0086     MOVWF FSR1
0677  0187     CLRF FSR1H
0678  0830     MOVF 0x30, W
0679  0081     MOVWF INDF1
79:                    mess[2] = 0x00;        
067A  0837     MOVF mess, W
067B  3E02     ADDLW 0x2
067C  0086     MOVWF FSR1
067D  0187     CLRF FSR1H
067E  0181     CLRF INDF1
067F  0008     RETURN
80:                    return;
81:                    
82:                } else { // 1 digit number
83:                    mess[0] = buf[2] + '0';
0680  0836     MOVF 0x36, W
0681  3E30     ADDLW 0x30
0682  00B0     MOVWF 0x30
0683  0837     MOVF mess, W
0684  0086     MOVWF FSR1
0685  0187     CLRF FSR1H
0686  0830     MOVF 0x30, W
0687  0081     MOVWF INDF1
84:                    mess[1] = 0x00;
0688  0A37     INCF mess, W
0689  0086     MOVWF FSR1
068A  0187     CLRF FSR1H
068B  0181     CLRF INDF1
85:                }
86:            }
068C  0008     RETURN
87:            
88:            unsigned char _gets(unsigned char *pt, unsigned char length)
89:            {
90:                unsigned char index;
91:             //read a line
92:                index = 0;
93:                while (index < length) {
94:                    pt[index] = EUSART1_Read();
95:                    if (pt[index] == 0x0a) {
96:                        index --; //uncommented only if CR+LN
97:                        return index; 
98:                    } 
99:                    index++;
100:               } 
101:               
102:               //error, buffer Overflow
103:               return 0;    
104:           }
105:           
106:           /*
107:           void tests()
108:           {
109:               unsigned char mess[5];   
110:               unsigned char val;
111:               
112:               val = 9;
113:               _sprintf_u8b(mess,val);
114:               
115:               val = 0;
116:               _sprintf_u8b(mess,val);
117:               
118:               val = 12;
119:               _sprintf_u8b(mess,val);
120:               
121:               val = 202;
122:               _sprintf_u8b(mess,val);
123:               
124:               val = 9;
125:               _sprintf_u8b(mess,val);      
126:               
127:           }
128:           */
---  /home/saul/MPLABXProjects/NEMS_v1.X/NEMS.c  --------------------------------------------------------
1:             #include "NEMS.h"
2:             #include "comm.h"
3:             #include "mcc_generated_files/tmr0.h"
4:             
5:             //Program settings
6:             
7:             volatile NEMS_program program;
8:             volatile NEMS_waveform waveform;
9:             
10:            volatile NEMS_state NEMS_states;
11:            volatile NEMS_wave_state NEMS_wave_states;
12:            volatile NEMS_pulse_state NEMS_pulse_states;
13:            
14:            void NEMS_initialize(void)
0E8A  318B     MOVLP 0xB
0E8B  2381     CALL 0x381
0E8C  318E     MOVLP 0xE
15:            {
16:                //Stop TMR0
17:                TMR0_StopTimer();
18:                       
19:                
20:                //Only for testing purposes
21:                program.amplitude = 1;
0E8D  3001     MOVLW 0x1
0E8E  0140     MOVLB 0x0
0E8F  00A2     MOVWF product
0E90  0822     MOVF product, W
0E91  00E1     MOVWF program
22:                program.frequency = 35;
0E92  3023     MOVLW 0x23
0E93  00A2     MOVWF product
0E94  0822     MOVF product, W
0E95  00E2     MOVWF 0x62
23:                program.phase_duration = 1;
0E96  3001     MOVLW 0x1
0E97  00A2     MOVWF product
0E98  0822     MOVF product, W
0E99  00E3     MOVWF 0x63
24:                program.ON_time = 2;
0E9A  3002     MOVLW 0x2
0E9B  00A2     MOVWF product
0E9C  0822     MOVF product, W
0E9D  00E5     MOVWF 0x65
25:                program.OFF_time = 6;
0E9E  3006     MOVLW 0x6
0E9F  00A2     MOVWF product
0EA0  0822     MOVF product, W
0EA1  00E6     MOVWF 0x66
26:                program.contractions = 5;
0EA2  3005     MOVLW 0x5
0EA3  00A2     MOVWF product
0EA4  0822     MOVF product, W
0EA5  00E7     MOVWF 0x67
27:                program.ramp_up = 10;
0EA6  300A     MOVLW 0xA
0EA7  00A2     MOVWF product
0EA8  0822     MOVF product, W
0EA9  00E8     MOVWF 0x68
28:                program.ramp_down = 10;
0EAA  300A     MOVLW 0xA
0EAB  00A2     MOVWF product
0EAC  0822     MOVF product, W
0EAD  00E9     MOVWF 0x69
29:                program.symmetry_factor = 1;
0EAE  3001     MOVLW 0x1
0EAF  00A2     MOVWF product
0EB0  0822     MOVF product, W
0EB1  00E4     MOVWF 0x64
30:                
31:                //Clear all program variables
32:                /*
33:                program.amplitude = 0;
34:                program.frequency = 0;
35:                program.phase_duration = 0;
36:                program.ON_time = 0;
37:                program.OFF_time = 0;
38:                program.contractions = 0;
39:                program.ramp_up = 0;
40:                program.ramp_down = 0;
41:                */
42:                //Redirect the interrupt handler
43:                TMR0_SetInterruptHandler(NEMS_timer);
0EB2  3046     MOVLW 0x46
0EB3  00A0     MOVWF __pcstackBANK0
0EB4  3000     MOVLW 0x0
0EB5  00A1     MOVWF addr
0EB6  318B     MOVLP 0xB
0EB7  2394     CALL 0x394
0EB8  318E     MOVLP 0xE
44:                
45:                DAC1_SetOutput(0);
0EB9  3000     MOVLW 0x0
0EBA  318B     MOVLP 0xB
0EBB  239E     CALL 0x39E
46:                    
47:            }
0EBC  0008     RETURN
48:            
49:            void NEMS_message_handler(void)
0779  318E     MOVLP 0xE
077A  260A     CALL 0x60A
077B  3187     MOVLP 0x7
077C  00C3     MOVWF 0x43
077D  0843     MOVF 0x43, W
077E  00C5     MOVWF header
50:            {
51:                unsigned char header;
52:                
53:                header = EUSART1_Read();
54:                
55:                switch (header) {
077F  2FB1     GOTO 0x7B1
56:                    case 't': // Test communications
57:                        _puts("Ok ");
0780  304D     MOVLW 0x4D
0781  00A2     MOVWF product
0782  3091     MOVLW 0x91
0783  00A3     MOVWF dividend
0784  318E     MOVLP 0xE
0785  262E     CALL 0x62E
58:                        break;
0786  0008     RETURN
59:                        
60:                    case 'a': // Set current amplitude [mA] 1 mA - 32 mA or higher (pp. 31, Chap 3)
61:                        NEMS_set_amplitude();
0787  318C     MOVLP 0xC
0788  24AB     CALL 0x4AB
62:                        break;
0789  0008     RETURN
63:                        
64:                    case 'f': // Set frequency [Hz] 15 - 50 (pp. 32, Chap 3))
65:                        NEMS_set_frequency();
078A  318C     MOVLP 0xC
078B  24D9     CALL 0x4D9
66:                        break;
078C  0008     RETURN
67:                        
68:                    case 'd': // Set phase duration [us/100] ( 200us - 400us --> 20 - 40) (pp. 83, Chap 6)
69:                        NEMS_set_phase_duration();
078D  318C     MOVLP 0xC
078E  24F0     CALL 0x4F0
70:                        break;
078F  0008     RETURN
71:                        
72:                    case 'k': // Set symmetry factor
73:                        NEMS_set_symmetry_factor();
0790  3187     MOVLP 0x7
0791  27E9     CALL 0x7E9
74:                        break;
0792  0008     RETURN
75:                        
76:                    case 'o': // Set ON time [s] 2s-4s (pp. 86, Chap 6) ON/OFF ~ 4:12, 1:3 
77:                        NEMS_set_ON_time();
0793  318C     MOVLP 0xC
0794  2494     CALL 0x494
78:                        break;
0795  0008     RETURN
79:                        
80:                    case 'O': // Set OFF time [s] ON/OFF 1/3 to 1/5  over 10-15 contractions
81:                        NEMS_set_OFF_time();
0796  318C     MOVLP 0xC
0797  247D     CALL 0x47D
82:                        break;
0798  0008     RETURN
83:                        
84:                    case 'c': // Set number of contractions
85:                        NEMS_set_contractions();
0799  318C     MOVLP 0xC
079A  24C2     CALL 0x4C2
86:                        break;
079B  0008     RETURN
87:                        
88:                    case 'r': // Set ramp-up time [ds] depends on the muscle and exercise, typically below 2s.(pp. 89, Chap 6)
89:                        NEMS_set_ramp_up();
079C  318D     MOVLP 0xD
079D  251E     CALL 0x51E
90:                        break;
079E  0008     RETURN
91:                        
92:                    case 'R': // Set ramp_down time [ds] 
93:                        NEMS_set_ramp_down();
079F  318D     MOVLP 0xD
07A0  2507     CALL 0x507
94:                        break;           
07A1  0008     RETURN
95:                    
96:                    case 'p': // Read current program configuration
97:                        NEMS_get_program();
07A2  3184     MOVLP 0x4
07A3  243D     CALL 0x43D
98:                        break;           
07A4  0008     RETURN
99:                        
100:                   case 's': // Save program configuration in EEPROM
101:                       NEMS_save_program();
07A5  3186     MOVLP 0x6
07A6  268D     CALL 0x68D
102:                       break;   
07A7  0008     RETURN
103:                       
104:                   case 'l': // Load program configuration from EEPROM
105:                       NEMS_load_program();
07A8  3187     MOVLP 0x7
07A9  2707     CALL 0x707
106:                       break;
07AA  0008     RETURN
107:                       
108:                   case 'n': // Start stimulation program
109:                       NEMS_start_program();
07AB  318C     MOVLP 0xC
07AC  242C     CALL 0x42C
110:                       break;
07AD  0008     RETURN
111:                       
112:                   case 'N': // Stop stimulation program
113:                       NEMS_stop_program();
07AE  318C     MOVLP 0xC
07AF  241B     CALL 0x41B
114:                       break;
07B0  0008     RETURN
115:                       
116:                   default: //Unknown header
117:                       break; 
118:               }
07B1  0845     MOVF header, W
07B2  00C3     MOVWF 0x43
07B3  01C4     CLRF 0x44
07B4  0844     MOVF 0x44, W
07B5  3A00     XORLW 0x0
07B6  1903     BTFSC STATUS, 0x2
07B7  2FB9     GOTO 0x7B9
07B8  2FE8     GOTO 0x7E8
07B9  0843     MOVF 0x43, W
07BA  3A4E     XORLW 0x4E
07BB  1903     BTFSC STATUS, 0x2
07BC  2FAE     GOTO 0x7AE
07BD  3A01     XORLW 0x1
07BE  1903     BTFSC STATUS, 0x2
07BF  2F96     GOTO 0x796
07C0  3A1D     XORLW 0x1D
07C1  1903     BTFSC STATUS, 0x2
07C2  2F9F     GOTO 0x79F
07C3  3A33     XORLW 0x33
07C4  1903     BTFSC STATUS, 0x2
07C5  2F87     GOTO 0x787
07C6  3A02     XORLW 0x2
07C7  1903     BTFSC STATUS, 0x2
07C8  2F99     GOTO 0x799
07C9  3A07     XORLW 0x7
07CA  1903     BTFSC STATUS, 0x2
07CB  2F8D     GOTO 0x78D
07CC  3A02     XORLW 0x2
07CD  1903     BTFSC STATUS, 0x2
07CE  2F8A     GOTO 0x78A
07CF  3A0D     XORLW 0xD
07D0  1903     BTFSC STATUS, 0x2
07D1  2F90     GOTO 0x790
07D2  3A07     XORLW 0x7
07D3  1903     BTFSC STATUS, 0x2
07D4  2FA8     GOTO 0x7A8
07D5  3A02     XORLW 0x2
07D6  1903     BTFSC STATUS, 0x2
07D7  2FAB     GOTO 0x7AB
07D8  3A01     XORLW 0x1
07D9  1903     BTFSC STATUS, 0x2
07DA  2F93     GOTO 0x793
07DB  3A1F     XORLW 0x1F
07DC  1903     BTFSC STATUS, 0x2
07DD  2FA2     GOTO 0x7A2
07DE  3A02     XORLW 0x2
07DF  1903     BTFSC STATUS, 0x2
07E0  2F9C     GOTO 0x79C
07E1  3A01     XORLW 0x1
07E2  1903     BTFSC STATUS, 0x2
07E3  2FA5     GOTO 0x7A5
07E4  3A07     XORLW 0x7
07E5  1903     BTFSC STATUS, 0x2
07E6  2F80     GOTO 0x780
07E7  2FE8     GOTO 0x7E8
119:               
120:           }
07E8  0008     RETURN
121:           
122:           unsigned char NEMS_get_packet(unsigned char* pt)
0F2D  0140     MOVLB 0x0
0F2E  00A8     MOVWF dividend
123:           {
124:               unsigned char message[2];
125:               
126:               __delay_ms(10);
0F2F  3068     MOVLW 0x68
0F30  0140     MOVLB 0x0
0F31  00A4     MOVWF counter
0F32  30E4     MOVLW 0xE4
0F33  0B89     DECFSZ WREG, F
0F34  2F33     GOTO 0x733
0F35  0BA4     DECFSZ counter, F
0F36  2F33     GOTO 0x733
0F37  0000     NOP
127:               
128:               if (eusart1RxCount == 2) { //Valid packet size
0F38  3002     MOVLW 0x2
0F39  0671     XORWF eusart1RxCount, W
0F3A  1D03     BTFSS STATUS, 0x2
0F3B  2F6A     GOTO 0x76A
129:                   message[0] = EUSART1_Read();
0F3C  318E     MOVLP 0xE
0F3D  260A     CALL 0x60A
0F3E  318F     MOVLP 0xF
0F3F  00A4     MOVWF counter
0F40  0824     MOVF counter, W
0F41  00A6     MOVWF divisor
130:                   message[1] = EUSART1_Read();
0F42  318E     MOVLP 0xE
0F43  260A     CALL 0x60A
0F44  318F     MOVLP 0xF
0F45  00A4     MOVWF counter
0F46  0824     MOVF counter, W
0F47  00A7     MOVWF index
131:                   
132:                   *pt = message[0] - '0';
0F48  0826     MOVF divisor, W
0F49  3ED0     ADDLW 0xD0
0F4A  00A4     MOVWF counter
0F4B  0828     MOVF dividend, W
0F4C  0086     MOVWF FSR1
0F4D  0187     CLRF FSR1H
0F4E  0824     MOVF counter, W
0F4F  0081     MOVWF INDF1
133:                   *pt *= 10;
0F50  0828     MOVF dividend, W
0F51  0086     MOVWF FSR1
0F52  0187     CLRF FSR1H
0F53  0801     MOVF INDF1, W
0F54  00A4     MOVWF counter
0F55  0824     MOVF counter, W
0F56  00A0     MOVWF __pcstackBANK0
0F57  300A     MOVLW 0xA
0F58  318C     MOVLP 0xC
0F59  240A     CALL 0x40A
0F5A  00A5     MOVWF rem
0F5B  0828     MOVF dividend, W
0F5C  0086     MOVWF FSR1
0F5D  0187     CLRF FSR1H
0F5E  0825     MOVF rem, W
0F5F  0081     MOVWF INDF1
134:                   *pt += message[1] - '0';
0F60  0827     MOVF index, W
0F61  3ED0     ADDLW 0xD0
0F62  00A4     MOVWF counter
0F63  0828     MOVF dividend, W
0F64  0086     MOVWF FSR1
0F65  0187     CLRF FSR1H
0F66  0824     MOVF counter, W
0F67  0781     ADDWF INDF1, F
135:                   
136:                   return 1;
0F68  3001     MOVLW 0x1
0F69  0008     RETURN
137:               } else {
138:                   return 0; // error, wrong packet's size 
0F6A  3000     MOVLW 0x0
139:               }    
140:           }
0F6B  0008     RETURN
141:           
142:           void NEMS_set_amplitude(void) 
0CAB  3061     MOVLW 0x61
0CAC  318F     MOVLP 0xF
0CAD  272D     CALL 0x72D
0CAE  318C     MOVLP 0xC
0CAF  3A00     XORLW 0x0
0CB0  1903     BTFSC STATUS, 0x2
0CB1  2CBA     GOTO 0x4BA
143:           {  
144:               if(NEMS_get_packet(&program.amplitude)) {
145:                   _puts("a-ok ");
0CB2  3011     MOVLW 0x11
0CB3  0140     MOVLB 0x0
0CB4  00A2     MOVWF product
0CB5  3091     MOVLW 0x91
0CB6  00A3     MOVWF dividend
0CB7  318E     MOVLP 0xE
0CB8  262E     CALL 0x62E
146:                   
147:               } else {
0CB9  0008     RETURN
148:                   _puts("a-err ");
0CBA  30CE     MOVLW 0xCE
0CBB  0140     MOVLB 0x0
0CBC  00A2     MOVWF product
0CBD  3090     MOVLW 0x90
0CBE  00A3     MOVWF dividend
0CBF  318E     MOVLP 0xE
0CC0  262E     CALL 0x62E
149:               }        
150:           }
0CC1  0008     RETURN
151:           
152:           void NEMS_set_frequency(void)
0CD9  3062     MOVLW 0x62
0CDA  318F     MOVLP 0xF
0CDB  272D     CALL 0x72D
0CDC  318C     MOVLP 0xC
0CDD  3A00     XORLW 0x0
0CDE  1903     BTFSC STATUS, 0x2
0CDF  2CE8     GOTO 0x4E8
153:           {
154:               if(NEMS_get_packet(&program.frequency)) {
155:                   _puts("f-ok ");
0CE0  3023     MOVLW 0x23
0CE1  0140     MOVLB 0x0
0CE2  00A2     MOVWF product
0CE3  3091     MOVLW 0x91
0CE4  00A3     MOVWF dividend
0CE5  318E     MOVLP 0xE
0CE6  262E     CALL 0x62E
156:                   
157:               } else {
0CE7  0008     RETURN
158:                   _puts("f-err ");
0CE8  30E3     MOVLW 0xE3
0CE9  0140     MOVLB 0x0
0CEA  00A2     MOVWF product
0CEB  3090     MOVLW 0x90
0CEC  00A3     MOVWF dividend
0CED  318E     MOVLP 0xE
0CEE  262E     CALL 0x62E
159:               }
160:           }
0CEF  0008     RETURN
161:           
162:           void NEMS_set_phase_duration(void)
0CF0  3063     MOVLW 0x63
0CF1  318F     MOVLP 0xF
0CF2  272D     CALL 0x72D
0CF3  318C     MOVLP 0xC
0CF4  3A00     XORLW 0x0
0CF5  1903     BTFSC STATUS, 0x2
0CF6  2CFF     GOTO 0x4FF
163:           {
164:               if(NEMS_get_packet(&program.phase_duration)) {
165:                   _puts("d-ok ");
0CF7  301D     MOVLW 0x1D
0CF8  0140     MOVLB 0x0
0CF9  00A2     MOVWF product
0CFA  3091     MOVLW 0x91
0CFB  00A3     MOVWF dividend
0CFC  318E     MOVLP 0xE
0CFD  262E     CALL 0x62E
166:                   
167:               } else {
0CFE  0008     RETURN
168:                   _puts("d-err ");
0CFF  30DC     MOVLW 0xDC
0D00  0140     MOVLB 0x0
0D01  00A2     MOVWF product
0D02  3090     MOVLW 0x90
0D03  00A3     MOVWF dividend
0D04  318E     MOVLP 0xE
0D05  262E     CALL 0x62E
169:               }
170:           }
0D06  0008     RETURN
171:           
172:           void NEMS_set_symmetry_factor(void)
07E9  3064     MOVLW 0x64
07EA  318F     MOVLP 0xF
07EB  272D     CALL 0x72D
07EC  3187     MOVLP 0x7
07ED  3A00     XORLW 0x0
07EE  1903     BTFSC STATUS, 0x2
07EF  2FF8     GOTO 0x7F8
173:           {
174:               if(NEMS_get_packet(&program.symmetry_factor)) {
175:                   _puts("k-ok ");
07F0  3029     MOVLW 0x29
07F1  0140     MOVLB 0x0
07F2  00A2     MOVWF product
07F3  3091     MOVLW 0x91
07F4  00A3     MOVWF dividend
07F5  318E     MOVLP 0xE
07F6  262E     CALL 0x62E
176:                   
177:               } else {
07F7  0008     RETURN
178:                   _puts("k-err ");
07F8  30EA     MOVLW 0xEA
07F9  0140     MOVLB 0x0
07FA  00A2     MOVWF product
07FB  3090     MOVLW 0x90
07FC  00A3     MOVWF dividend
07FD  318E     MOVLP 0xE
07FE  262E     CALL 0x62E
179:               }
180:           
181:           }
07FF  0008     RETURN
182:           
183:           void NEMS_set_ON_time(void)
0C94  3065     MOVLW 0x65
0C95  318F     MOVLP 0xF
0C96  272D     CALL 0x72D
0C97  318C     MOVLP 0xC
0C98  3A00     XORLW 0x0
0C99  1903     BTFSC STATUS, 0x2
0C9A  2CA3     GOTO 0x4A3
184:           {
185:               if(NEMS_get_packet(&program.ON_time)) {
186:                   _puts("o-ok ");
0C9B  303B     MOVLW 0x3B
0C9C  0140     MOVLB 0x0
0C9D  00A2     MOVWF product
0C9E  3091     MOVLW 0x91
0C9F  00A3     MOVWF dividend
0CA0  318E     MOVLP 0xE
0CA1  262E     CALL 0x62E
187:                   
188:               } else {
0CA2  0008     RETURN
189:                   _puts("o-err ");
0CA3  30F1     MOVLW 0xF1
0CA4  0140     MOVLB 0x0
0CA5  00A2     MOVWF product
0CA6  3090     MOVLW 0x90
0CA7  00A3     MOVWF dividend
0CA8  318E     MOVLP 0xE
0CA9  262E     CALL 0x62E
190:               }        
191:           }
0CAA  0008     RETURN
192:           
193:           void NEMS_set_OFF_time(void)
0C7D  3066     MOVLW 0x66
0C7E  318F     MOVLP 0xF
0C7F  272D     CALL 0x72D
0C80  318C     MOVLP 0xC
0C81  3A00     XORLW 0x0
0C82  1903     BTFSC STATUS, 0x2
0C83  2C8C     GOTO 0x48C
194:           {
195:               if(NEMS_get_packet(&program.OFF_time)) {
196:                   _puts("O-ok ");
0C84  3005     MOVLW 0x5
0C85  0140     MOVLB 0x0
0C86  00A2     MOVWF product
0C87  3091     MOVLW 0x91
0C88  00A3     MOVWF dividend
0C89  318E     MOVLP 0xE
0C8A  262E     CALL 0x62E
197:                   
198:               } else {
0C8B  0008     RETURN
199:                   _puts("O-err ");
0C8C  30C0     MOVLW 0xC0
0C8D  0140     MOVLB 0x0
0C8E  00A2     MOVWF product
0C8F  3090     MOVLW 0x90
0C90  00A3     MOVWF dividend
0C91  318E     MOVLP 0xE
0C92  262E     CALL 0x62E
200:               }
201:           }
0C93  0008     RETURN
202:           
203:           void NEMS_set_contractions(void)
0CC2  3067     MOVLW 0x67
0CC3  318F     MOVLP 0xF
0CC4  272D     CALL 0x72D
0CC5  318C     MOVLP 0xC
0CC6  3A00     XORLW 0x0
0CC7  1903     BTFSC STATUS, 0x2
0CC8  2CD1     GOTO 0x4D1
204:           {
205:               if(NEMS_get_packet(&program.contractions)) {
206:                   _puts("c-ok ");
0CC9  3017     MOVLW 0x17
0CCA  0140     MOVLB 0x0
0CCB  00A2     MOVWF product
0CCC  3091     MOVLW 0x91
0CCD  00A3     MOVWF dividend
0CCE  318E     MOVLP 0xE
0CCF  262E     CALL 0x62E
207:                   
208:               } else {
0CD0  0008     RETURN
209:                   _puts("c-err ");
0CD1  30D5     MOVLW 0xD5
0CD2  0140     MOVLB 0x0
0CD3  00A2     MOVWF product
0CD4  3090     MOVLW 0x90
0CD5  00A3     MOVWF dividend
0CD6  318E     MOVLP 0xE
0CD7  262E     CALL 0x62E
210:               }
211:           }
0CD8  0008     RETURN
212:           
213:           void NEMS_set_ramp_up(void)
0D1E  3068     MOVLW 0x68
0D1F  318F     MOVLP 0xF
0D20  272D     CALL 0x72D
0D21  318D     MOVLP 0xD
0D22  3A00     XORLW 0x0
0D23  1903     BTFSC STATUS, 0x2
0D24  2D2D     GOTO 0x52D
214:           {
215:               if(NEMS_get_packet(&program.ramp_up)) {
216:                   _puts("r-ok ");
0D25  3041     MOVLW 0x41
0D26  0140     MOVLB 0x0
0D27  00A2     MOVWF product
0D28  3091     MOVLW 0x91
0D29  00A3     MOVWF dividend
0D2A  318E     MOVLP 0xE
0D2B  262E     CALL 0x62E
217:                   
218:               } else {
0D2C  0008     RETURN
219:                   _puts("r-err ");
0D2D  30F8     MOVLW 0xF8
0D2E  0140     MOVLB 0x0
0D2F  00A2     MOVWF product
0D30  3090     MOVLW 0x90
0D31  00A3     MOVWF dividend
0D32  318E     MOVLP 0xE
0D33  262E     CALL 0x62E
220:               }
221:               
222:           }
0D34  0008     RETURN
223:           
224:           void NEMS_set_ramp_down(void)
0D07  3069     MOVLW 0x69
0D08  318F     MOVLP 0xF
0D09  272D     CALL 0x72D
0D0A  318D     MOVLP 0xD
0D0B  3A00     XORLW 0x0
0D0C  1903     BTFSC STATUS, 0x2
0D0D  2D16     GOTO 0x516
225:           {
226:               if(NEMS_get_packet(&program.ramp_down)) {
227:                   _puts("R-ok ");
0D0E  300B     MOVLW 0xB
0D0F  0140     MOVLB 0x0
0D10  00A2     MOVWF product
0D11  3091     MOVLW 0x91
0D12  00A3     MOVWF dividend
0D13  318E     MOVLP 0xE
0D14  262E     CALL 0x62E
228:                   
229:               } else {
0D15  0008     RETURN
230:                   _puts("R-err ");
0D16  30C7     MOVLW 0xC7
0D17  0140     MOVLB 0x0
0D18  00A2     MOVWF product
0D19  3090     MOVLW 0x90
0D1A  00A3     MOVWF dividend
0D1B  318E     MOVLP 0xE
0D1C  262E     CALL 0x62E
231:               }
232:           }
0D1D  0008     RETURN
233:           
234:           void NEMS_get_program(void)
043D  30A2     MOVLW 0xA2
043E  0140     MOVLB 0x0
043F  00A2     MOVWF product
0440  3090     MOVLW 0x90
0441  00A3     MOVWF dividend
0442  318E     MOVLP 0xE
0443  262E     CALL 0x62E
0444  3184     MOVLP 0x4
235:           {
236:               unsigned char aux[4];
237:               
238:               _puts("\nNEMS program\n");    
239:               
240:               _sprintf_u8b(aux,program.amplitude);    
0445  0861     MOVF program, W
0446  00B8     MOVWF 0x38
0447  0838     MOVF 0x38, W
0448  00AF     MOVWF val
0449  3039     MOVLW 0x39
044A  3185     MOVLP 0x5
044B  25FE     CALL 0x5FE
044C  3184     MOVLP 0x4
241:               _puts("Amplitude (mA): ");
044D  3070     MOVLW 0x70
044E  00A2     MOVWF product
044F  3090     MOVLW 0x90
0450  00A3     MOVWF dividend
0451  318E     MOVLP 0xE
0452  262E     CALL 0x62E
0453  3184     MOVLP 0x4
242:               _puts(aux);
0454  3039     MOVLW 0x39
0455  00A2     MOVWF product
0456  3000     MOVLW 0x0
0457  00A3     MOVWF dividend
0458  318E     MOVLP 0xE
0459  262E     CALL 0x62E
045A  3184     MOVLP 0x4
243:               _puts("\n");
045B  30AF     MOVLW 0xAF
045C  00A2     MOVWF product
045D  3090     MOVLW 0x90
045E  00A3     MOVWF dividend
045F  318E     MOVLP 0xE
0460  262E     CALL 0x62E
0461  3184     MOVLP 0x4
244:               
245:               _sprintf_u8b(aux,program.frequency);
0462  0862     MOVF 0x62, W
0463  00B8     MOVWF 0x38
0464  0838     MOVF 0x38, W
0465  00AF     MOVWF val
0466  3039     MOVLW 0x39
0467  3185     MOVLP 0x5
0468  25FE     CALL 0x5FE
0469  3184     MOVLP 0x4
246:               _puts("Frequency (Hz): ");
046A  3081     MOVLW 0x81
046B  00A2     MOVWF product
046C  3090     MOVLW 0x90
046D  00A3     MOVWF dividend
046E  318E     MOVLP 0xE
046F  262E     CALL 0x62E
0470  3184     MOVLP 0x4
247:               _puts(aux);
0471  3039     MOVLW 0x39
0472  00A2     MOVWF product
0473  3000     MOVLW 0x0
0474  00A3     MOVWF dividend
0475  318E     MOVLP 0xE
0476  262E     CALL 0x62E
0477  3184     MOVLP 0x4
248:               _puts("\n");
0478  30AF     MOVLW 0xAF
0479  00A2     MOVWF product
047A  3090     MOVLW 0x90
047B  00A3     MOVWF dividend
047C  318E     MOVLP 0xE
047D  262E     CALL 0x62E
047E  3184     MOVLP 0x4
249:               
250:               _sprintf_u8b(aux,program.phase_duration);
047F  0863     MOVF 0x63, W
0480  00B8     MOVWF 0x38
0481  0838     MOVF 0x38, W
0482  00AF     MOVWF val
0483  3039     MOVLW 0x39
0484  3185     MOVLP 0x5
0485  25FE     CALL 0x5FE
0486  3184     MOVLP 0x4
251:               _puts("Phase duration (us/50): ");
0487  3000     MOVLW 0x0
0488  00A2     MOVWF product
0489  3090     MOVLW 0x90
048A  00A3     MOVWF dividend
048B  318E     MOVLP 0xE
048C  262E     CALL 0x62E
048D  3184     MOVLP 0x4
252:               _puts(aux);
048E  3039     MOVLW 0x39
048F  00A2     MOVWF product
0490  3000     MOVLW 0x0
0491  00A3     MOVWF dividend
0492  318E     MOVLP 0xE
0493  262E     CALL 0x62E
0494  3184     MOVLP 0x4
253:               _puts("\n");
0495  30AF     MOVLW 0xAF
0496  00A2     MOVWF product
0497  3090     MOVLW 0x90
0498  00A3     MOVWF dividend
0499  318E     MOVLP 0xE
049A  262E     CALL 0x62E
049B  3184     MOVLP 0x4
254:               
255:                _sprintf_u8b(aux,program.symmetry_factor);
049C  0864     MOVF 0x64, W
049D  00B8     MOVWF 0x38
049E  0838     MOVF 0x38, W
049F  00AF     MOVWF val
04A0  3039     MOVLW 0x39
04A1  3185     MOVLP 0x5
04A2  25FE     CALL 0x5FE
04A3  3184     MOVLP 0x4
256:               _puts("Symmetry factor: ");
04A4  305E     MOVLW 0x5E
04A5  00A2     MOVWF product
04A6  3090     MOVLW 0x90
04A7  00A3     MOVWF dividend
04A8  318E     MOVLP 0xE
04A9  262E     CALL 0x62E
04AA  3184     MOVLP 0x4
257:               _puts(aux);
04AB  3039     MOVLW 0x39
04AC  00A2     MOVWF product
04AD  3000     MOVLW 0x0
04AE  00A3     MOVWF dividend
04AF  318E     MOVLP 0xE
04B0  262E     CALL 0x62E
04B1  3184     MOVLP 0x4
258:               _puts("\n");
04B2  30AF     MOVLW 0xAF
04B3  00A2     MOVWF product
04B4  3090     MOVLW 0x90
04B5  00A3     MOVWF dividend
04B6  318E     MOVLP 0xE
04B7  262E     CALL 0x62E
04B8  3184     MOVLP 0x4
259:               
260:               _sprintf_u8b(aux,program.ON_time);
04B9  0865     MOVF 0x65, W
04BA  00B8     MOVWF 0x38
04BB  0838     MOVF 0x38, W
04BC  00AF     MOVWF val
04BD  3039     MOVLW 0x39
04BE  3185     MOVLP 0x5
04BF  25FE     CALL 0x5FE
04C0  3184     MOVLP 0x4
261:               _puts("ON time (s) : ");
04C1  30B1     MOVLW 0xB1
04C2  00A2     MOVWF product
04C3  3090     MOVLW 0x90
04C4  00A3     MOVWF dividend
04C5  318E     MOVLP 0xE
04C6  262E     CALL 0x62E
04C7  3184     MOVLP 0x4
262:               _puts(aux);
04C8  3039     MOVLW 0x39
04C9  00A2     MOVWF product
04CA  3000     MOVLW 0x0
04CB  00A3     MOVWF dividend
04CC  318E     MOVLP 0xE
04CD  262E     CALL 0x62E
04CE  3184     MOVLP 0x4
263:               _puts("\n");
04CF  30AF     MOVLW 0xAF
04D0  00A2     MOVWF product
04D1  3090     MOVLW 0x90
04D2  00A3     MOVWF dividend
04D3  318E     MOVLP 0xE
04D4  262E     CALL 0x62E
04D5  3184     MOVLP 0x4
264:               
265:               _sprintf_u8b(aux,program.OFF_time);
04D6  0866     MOVF 0x66, W
04D7  00B8     MOVWF 0x38
04D8  0838     MOVF 0x38, W
04D9  00AF     MOVWF val
04DA  3039     MOVLW 0x39
04DB  3185     MOVLP 0x5
04DC  25FE     CALL 0x5FE
04DD  3184     MOVLP 0x4
266:               _puts("OFF time (s) : ");
04DE  3092     MOVLW 0x92
04DF  00A2     MOVWF product
04E0  3090     MOVLW 0x90
04E1  00A3     MOVWF dividend
04E2  318E     MOVLP 0xE
04E3  262E     CALL 0x62E
04E4  3184     MOVLP 0x4
267:               _puts(aux);
04E5  3039     MOVLW 0x39
04E6  00A2     MOVWF product
04E7  3000     MOVLW 0x0
04E8  00A3     MOVWF dividend
04E9  318E     MOVLP 0xE
04EA  262E     CALL 0x62E
04EB  3184     MOVLP 0x4
268:               _puts("\n");
04EC  30AF     MOVLW 0xAF
04ED  00A2     MOVWF product
04EE  3090     MOVLW 0x90
04EF  00A3     MOVWF dividend
04F0  318E     MOVLP 0xE
04F1  262E     CALL 0x62E
04F2  3184     MOVLP 0x4
269:               
270:               _sprintf_u8b(aux,program.ramp_up);
04F3  0868     MOVF 0x68, W
04F4  00B8     MOVWF 0x38
04F5  0838     MOVF 0x38, W
04F6  00AF     MOVWF val
04F7  3039     MOVLW 0x39
04F8  3185     MOVLP 0x5
04F9  25FE     CALL 0x5FE
04FA  3184     MOVLP 0x4
271:               _puts("Ramp up time (ds) : ");
04FB  3049     MOVLW 0x49
04FC  00A2     MOVWF product
04FD  3090     MOVLW 0x90
04FE  00A3     MOVWF dividend
04FF  318E     MOVLP 0xE
0500  262E     CALL 0x62E
0501  3184     MOVLP 0x4
272:               _puts(aux);
0502  3039     MOVLW 0x39
0503  00A2     MOVWF product
0504  3000     MOVLW 0x0
0505  00A3     MOVWF dividend
0506  318E     MOVLP 0xE
0507  262E     CALL 0x62E
0508  3184     MOVLP 0x4
273:               _puts("\n");
0509  30AF     MOVLW 0xAF
050A  00A2     MOVWF product
050B  3090     MOVLW 0x90
050C  00A3     MOVWF dividend
050D  318E     MOVLP 0xE
050E  262E     CALL 0x62E
050F  3184     MOVLP 0x4
274:               
275:               _sprintf_u8b(aux,program.ramp_down);
0510  0869     MOVF 0x69, W
0511  00B8     MOVWF 0x38
0512  0838     MOVF 0x38, W
0513  00AF     MOVWF val
0514  3039     MOVLW 0x39
0515  3185     MOVLP 0x5
0516  25FE     CALL 0x5FE
0517  3184     MOVLP 0x4
276:               _puts("Ramp down time (ds) : ");
0518  3032     MOVLW 0x32
0519  00A2     MOVWF product
051A  3090     MOVLW 0x90
051B  00A3     MOVWF dividend
051C  318E     MOVLP 0xE
051D  262E     CALL 0x62E
051E  3184     MOVLP 0x4
277:               _puts(aux);
051F  3039     MOVLW 0x39
0520  00A2     MOVWF product
0521  3000     MOVLW 0x0
0522  00A3     MOVWF dividend
0523  318E     MOVLP 0xE
0524  262E     CALL 0x62E
0525  3184     MOVLP 0x4
278:               _puts("\n");
0526  30AF     MOVLW 0xAF
0527  00A2     MOVWF product
0528  3090     MOVLW 0x90
0529  00A3     MOVWF dividend
052A  318E     MOVLP 0xE
052B  262E     CALL 0x62E
052C  3184     MOVLP 0x4
279:               
280:               _sprintf_u8b(aux,program.contractions);
052D  0867     MOVF 0x67, W
052E  00B8     MOVWF 0x38
052F  0838     MOVF 0x38, W
0530  00AF     MOVWF val
0531  3039     MOVLW 0x39
0532  3185     MOVLP 0x5
0533  25FE     CALL 0x5FE
0534  3184     MOVLP 0x4
281:               _puts("Number of contractions: ");
0535  3019     MOVLW 0x19
0536  00A2     MOVWF product
0537  3090     MOVLW 0x90
0538  00A3     MOVWF dividend
0539  318E     MOVLP 0xE
053A  262E     CALL 0x62E
053B  3184     MOVLP 0x4
282:               _puts(aux);
053C  3039     MOVLW 0x39
053D  00A2     MOVWF product
053E  3000     MOVLW 0x0
053F  00A3     MOVWF dividend
0540  318E     MOVLP 0xE
0541  262E     CALL 0x62E
0542  3184     MOVLP 0x4
283:               _puts("\n");    
0543  30AF     MOVLW 0xAF
0544  00A2     MOVWF product
0545  3090     MOVLW 0x90
0546  00A3     MOVWF dividend
0547  318E     MOVLP 0xE
0548  262E     CALL 0x62E
284:               
285:           }
0549  0008     RETURN
286:           
287:           void NEMS_save_program(void)
068D  0140     MOVLB 0x0
068E  01A9     CLRF addr
288:           {
289:               unsigned char addr;
290:               
291:               addr = 0;
292:               eeprom_write(addr++,program.amplitude);
068F  0861     MOVF program, W
0690  00A8     MOVWF dividend
0691  0828     MOVF dividend, W
0692  00A0     MOVWF __pcstackBANK0
0693  3000     MOVLW 0x0
0694  318D     MOVLP 0xD
0695  25C6     CALL 0x5C6
0696  3186     MOVLP 0x6
0697  3001     MOVLW 0x1
0698  0140     MOVLB 0x0
0699  00A8     MOVWF dividend
069A  0828     MOVF dividend, W
069B  07A9     ADDWF addr, F
293:               eeprom_write(addr++,program.frequency);
069C  0862     MOVF 0x62, W
069D  00A8     MOVWF dividend
069E  0828     MOVF dividend, W
069F  00A0     MOVWF __pcstackBANK0
06A0  0829     MOVF addr, W
06A1  318D     MOVLP 0xD
06A2  25C6     CALL 0x5C6
06A3  3186     MOVLP 0x6
06A4  3001     MOVLW 0x1
06A5  0140     MOVLB 0x0
06A6  00A8     MOVWF dividend
06A7  0828     MOVF dividend, W
06A8  07A9     ADDWF addr, F
294:               eeprom_write(addr++,program.phase_duration);
06A9  0863     MOVF 0x63, W
06AA  00A8     MOVWF dividend
06AB  0828     MOVF dividend, W
06AC  00A0     MOVWF __pcstackBANK0
06AD  0829     MOVF addr, W
06AE  318D     MOVLP 0xD
06AF  25C6     CALL 0x5C6
06B0  3186     MOVLP 0x6
06B1  3001     MOVLW 0x1
06B2  0140     MOVLB 0x0
06B3  00A8     MOVWF dividend
06B4  0828     MOVF dividend, W
06B5  07A9     ADDWF addr, F
295:               eeprom_write(addr++,program.symmetry_factor);
06B6  0864     MOVF 0x64, W
06B7  00A8     MOVWF dividend
06B8  0828     MOVF dividend, W
06B9  00A0     MOVWF __pcstackBANK0
06BA  0829     MOVF addr, W
06BB  318D     MOVLP 0xD
06BC  25C6     CALL 0x5C6
06BD  3186     MOVLP 0x6
06BE  3001     MOVLW 0x1
06BF  0140     MOVLB 0x0
06C0  00A8     MOVWF dividend
06C1  0828     MOVF dividend, W
06C2  07A9     ADDWF addr, F
296:               eeprom_write(addr++,program.ON_time);
06C3  0865     MOVF 0x65, W
06C4  00A8     MOVWF dividend
06C5  0828     MOVF dividend, W
06C6  00A0     MOVWF __pcstackBANK0
06C7  0829     MOVF addr, W
06C8  318D     MOVLP 0xD
06C9  25C6     CALL 0x5C6
06CA  3186     MOVLP 0x6
06CB  3001     MOVLW 0x1
06CC  0140     MOVLB 0x0
06CD  00A8     MOVWF dividend
06CE  0828     MOVF dividend, W
06CF  07A9     ADDWF addr, F
297:               eeprom_write(addr++,program.OFF_time);
06D0  0866     MOVF 0x66, W
06D1  00A8     MOVWF dividend
06D2  0828     MOVF dividend, W
06D3  00A0     MOVWF __pcstackBANK0
06D4  0829     MOVF addr, W
06D5  318D     MOVLP 0xD
06D6  25C6     CALL 0x5C6
06D7  3186     MOVLP 0x6
06D8  3001     MOVLW 0x1
06D9  0140     MOVLB 0x0
06DA  00A8     MOVWF dividend
06DB  0828     MOVF dividend, W
06DC  07A9     ADDWF addr, F
298:               eeprom_write(addr++,program.ramp_up);
06DD  0868     MOVF 0x68, W
06DE  00A8     MOVWF dividend
06DF  0828     MOVF dividend, W
06E0  00A0     MOVWF __pcstackBANK0
06E1  0829     MOVF addr, W
06E2  318D     MOVLP 0xD
06E3  25C6     CALL 0x5C6
06E4  3186     MOVLP 0x6
06E5  3001     MOVLW 0x1
06E6  0140     MOVLB 0x0
06E7  00A8     MOVWF dividend
06E8  0828     MOVF dividend, W
06E9  07A9     ADDWF addr, F
299:               eeprom_write(addr++,program.ramp_down);
06EA  0869     MOVF 0x69, W
06EB  00A8     MOVWF dividend
06EC  0828     MOVF dividend, W
06ED  00A0     MOVWF __pcstackBANK0
06EE  0829     MOVF addr, W
06EF  318D     MOVLP 0xD
06F0  25C6     CALL 0x5C6
06F1  3186     MOVLP 0x6
06F2  3001     MOVLW 0x1
06F3  0140     MOVLB 0x0
06F4  00A8     MOVWF dividend
06F5  0828     MOVF dividend, W
06F6  07A9     ADDWF addr, F
300:               eeprom_write(addr,program.contractions);
06F7  0867     MOVF 0x67, W
06F8  00A8     MOVWF dividend
06F9  0828     MOVF dividend, W
06FA  00A0     MOVWF __pcstackBANK0
06FB  0829     MOVF addr, W
06FC  318D     MOVLP 0xD
06FD  25C6     CALL 0x5C6
06FE  3186     MOVLP 0x6
301:                   
302:               _puts("s-ok ");
06FF  3047     MOVLW 0x47
0700  0140     MOVLB 0x0
0701  00A2     MOVWF product
0702  3091     MOVLW 0x91
0703  00A3     MOVWF dividend
0704  318E     MOVLP 0xE
0705  262E     CALL 0x62E
303:               
304:           }
0706  0008     RETURN
305:           
306:           void NEMS_load_program(void)
0707  0140     MOVLB 0x0
0708  01A9     CLRF addr
0709  01AA     CLRF 0x2A
307:           {
308:               unsigned short addr;
309:               
310:               addr = 0;
311:               
312:               program.amplitude = eeprom_read(addr++);
070A  3000     MOVLW 0x0
070B  318B     MOVLP 0xB
070C  23F9     CALL 0x3F9
070D  3187     MOVLP 0x7
070E  0140     MOVLB 0x0
070F  00A8     MOVWF dividend
0710  0828     MOVF dividend, W
0711  00E1     MOVWF program
0712  3001     MOVLW 0x1
0713  07A9     ADDWF addr, F
0714  3000     MOVLW 0x0
0715  3DAA     ADDWFC 0x2A, F
313:               program.frequency = eeprom_read(addr++);
0716  0829     MOVF addr, W
0717  318B     MOVLP 0xB
0718  23F9     CALL 0x3F9
0719  3187     MOVLP 0x7
071A  0140     MOVLB 0x0
071B  00A8     MOVWF dividend
071C  0828     MOVF dividend, W
071D  00E2     MOVWF 0x62
071E  3001     MOVLW 0x1
071F  07A9     ADDWF addr, F
0720  3000     MOVLW 0x0
0721  3DAA     ADDWFC 0x2A, F
314:               program.phase_duration = eeprom_read(addr++);
0722  0829     MOVF addr, W
0723  318B     MOVLP 0xB
0724  23F9     CALL 0x3F9
0725  3187     MOVLP 0x7
0726  0140     MOVLB 0x0
0727  00A8     MOVWF dividend
0728  0828     MOVF dividend, W
0729  00E3     MOVWF 0x63
072A  3001     MOVLW 0x1
072B  07A9     ADDWF addr, F
072C  3000     MOVLW 0x0
072D  3DAA     ADDWFC 0x2A, F
315:               program.symmetry_factor = eeprom_read(addr++);
072E  0829     MOVF addr, W
072F  318B     MOVLP 0xB
0730  23F9     CALL 0x3F9
0731  3187     MOVLP 0x7
0732  0140     MOVLB 0x0
0733  00A8     MOVWF dividend
0734  0828     MOVF dividend, W
0735  00E4     MOVWF 0x64
0736  3001     MOVLW 0x1
0737  07A9     ADDWF addr, F
0738  3000     MOVLW 0x0
0739  3DAA     ADDWFC 0x2A, F
316:               program.ON_time = eeprom_read(addr++);
073A  0829     MOVF addr, W
073B  318B     MOVLP 0xB
073C  23F9     CALL 0x3F9
073D  3187     MOVLP 0x7
073E  0140     MOVLB 0x0
073F  00A8     MOVWF dividend
0740  0828     MOVF dividend, W
0741  00E5     MOVWF 0x65
0742  3001     MOVLW 0x1
0743  07A9     ADDWF addr, F
0744  3000     MOVLW 0x0
0745  3DAA     ADDWFC 0x2A, F
317:               program.OFF_time = eeprom_read(addr++);
0746  0829     MOVF addr, W
0747  318B     MOVLP 0xB
0748  23F9     CALL 0x3F9
0749  3187     MOVLP 0x7
074A  0140     MOVLB 0x0
074B  00A8     MOVWF dividend
074C  0828     MOVF dividend, W
074D  00E6     MOVWF 0x66
074E  3001     MOVLW 0x1
074F  07A9     ADDWF addr, F
0750  3000     MOVLW 0x0
0751  3DAA     ADDWFC 0x2A, F
318:               program.ramp_up = eeprom_read(addr++);
0752  0829     MOVF addr, W
0753  318B     MOVLP 0xB
0754  23F9     CALL 0x3F9
0755  3187     MOVLP 0x7
0756  0140     MOVLB 0x0
0757  00A8     MOVWF dividend
0758  0828     MOVF dividend, W
0759  00E8     MOVWF 0x68
075A  3001     MOVLW 0x1
075B  07A9     ADDWF addr, F
075C  3000     MOVLW 0x0
075D  3DAA     ADDWFC 0x2A, F
319:               program.ramp_down = eeprom_read(addr++);
075E  0829     MOVF addr, W
075F  318B     MOVLP 0xB
0760  23F9     CALL 0x3F9
0761  3187     MOVLP 0x7
0762  0140     MOVLB 0x0
0763  00A8     MOVWF dividend
0764  0828     MOVF dividend, W
0765  00E9     MOVWF 0x69
0766  3001     MOVLW 0x1
0767  07A9     ADDWF addr, F
0768  3000     MOVLW 0x0
0769  3DAA     ADDWFC 0x2A, F
320:               program.contractions = eeprom_read(addr);
076A  0829     MOVF addr, W
076B  318B     MOVLP 0xB
076C  23F9     CALL 0x3F9
076D  3187     MOVLP 0x7
076E  0140     MOVLB 0x0
076F  00A8     MOVWF dividend
0770  0828     MOVF dividend, W
0771  00E7     MOVWF 0x67
321:               
322:               _puts("l-ok ");
0772  302F     MOVLW 0x2F
0773  00A2     MOVWF product
0774  3091     MOVLW 0x91
0775  00A3     MOVWF dividend
0776  318E     MOVLP 0xE
0777  262E     CALL 0x62E
323:           }
0778  0008     RETURN
324:           
325:           void NEMS_recalculate_program(void)
0322  0140     MOVLB 0x0
0323  0862     MOVF 0x62, W
0324  00BC     MOVWF 0x3C
0325  01BD     CLRF 0x3D
0326  083C     MOVF 0x3C, W
0327  00A6     MOVWF divisor
0328  083D     MOVF 0x3D, W
0329  00A7     MOVWF index
032A  3020     MOVLW 0x20
032B  00A8     MOVWF dividend
032C  304E     MOVLW 0x4E
032D  00A9     MOVWF addr
032E  318E     MOVLP 0xE
032F  26BD     CALL 0x6BD
0330  3183     MOVLP 0x3
0331  300D     MOVLW 0xD
0332  0086     MOVWF FSR1
0333  3027     MOVLW 0x27
0334  0087     MOVWF FSR1H
0335  0826     MOVF divisor, W
0336  3FC0     MOVWI [0]FSR1
0337  0827     MOVF index, W
0338  3FC1     MOVWI [1]FSR1
326:           {
327:               waveform.num_clocks_per_pulse = (unsigned short)NEMS_TIMER_FREQUENCY/program.frequency;
328:               waveform.clock_index = 0;
0339  300D     MOVLW 0xD
033A  0086     MOVWF FSR1
033B  3027     MOVLW 0x27
033C  0087     MOVWF FSR1H
033D  3142     ADDFSR 1, 2
033E  3000     MOVLW 0x0
033F  3FC0     MOVWI [0]FSR1
0340  3FC1     MOVWI [1]FSR1
329:               waveform.pulse_index = 0;
0341  300D     MOVLW 0xD
0342  0086     MOVWF FSR1
0343  3027     MOVLW 0x27
0344  0087     MOVWF FSR1H
0345  3144     ADDFSR 1, 4
0346  3000     MOVLW 0x0
0347  3FC0     MOVWI [0]FSR1
0348  3FC1     MOVWI [1]FSR1
330:               
331:               waveform.ramp_up_pulses = (program.ramp_up*program.frequency)/10;  
0349  300A     MOVLW 0xA
034A  00A6     MOVWF divisor
034B  3000     MOVLW 0x0
034C  00A7     MOVWF index
034D  0868     MOVF 0x68, W
034E  00BC     MOVWF 0x3C
034F  01BD     CLRF 0x3D
0350  083C     MOVF 0x3C, W
0351  00A0     MOVWF __pcstackBANK0
0352  083D     MOVF 0x3D, W
0353  00A1     MOVWF addr
0354  0862     MOVF 0x62, W
0355  00BE     MOVWF 0x3E
0356  01BF     CLRF 0x3F
0357  083E     MOVF 0x3E, W
0358  00A2     MOVWF product
0359  083F     MOVF 0x3F, W
035A  00A3     MOVWF dividend
035B  318D     MOVLP 0xD
035C  2535     CALL 0x535
035D  3183     MOVLP 0x3
035E  0821     MOVF addr, W
035F  00A9     MOVWF addr
0360  0820     MOVF __pcstackBANK0, W
0361  00A8     MOVWF dividend
0362  318F     MOVLP 0xF
0363  27AF     CALL 0x7AF
0364  3183     MOVLP 0x3
0365  3082     MOVLW 0x82
0366  0086     MOVWF FSR1
0367  3027     MOVLW 0x27
0368  0087     MOVWF FSR1H
0369  0826     MOVF divisor, W
036A  3FC0     MOVWI [0]FSR1
036B  0827     MOVF index, W
036C  3FC1     MOVWI [1]FSR1
332:               waveform.ramp_down_pulses = (program.ramp_down*program.frequency)/10;
036D  300A     MOVLW 0xA
036E  00A6     MOVWF divisor
036F  3000     MOVLW 0x0
0370  00A7     MOVWF index
0371  0869     MOVF 0x69, W
0372  00BC     MOVWF 0x3C
0373  01BD     CLRF 0x3D
0374  083C     MOVF 0x3C, W
0375  00A0     MOVWF __pcstackBANK0
0376  083D     MOVF 0x3D, W
0377  00A1     MOVWF addr
0378  0862     MOVF 0x62, W
0379  00BE     MOVWF 0x3E
037A  01BF     CLRF 0x3F
037B  083E     MOVF 0x3E, W
037C  00A2     MOVWF product
037D  083F     MOVF 0x3F, W
037E  00A3     MOVWF dividend
037F  318D     MOVLP 0xD
0380  2535     CALL 0x535
0381  3183     MOVLP 0x3
0382  0821     MOVF addr, W
0383  00A9     MOVWF addr
0384  0820     MOVF __pcstackBANK0, W
0385  00A8     MOVWF dividend
0386  318F     MOVLP 0xF
0387  27AF     CALL 0x7AF
0388  3183     MOVLP 0x3
0389  30EA     MOVLW 0xEA
038A  0086     MOVWF FSR1
038B  3027     MOVLW 0x27
038C  0087     MOVWF FSR1H
038D  0826     MOVF divisor, W
038E  3FC0     MOVWI [0]FSR1
038F  0827     MOVF index, W
0390  3FC1     MOVWI [1]FSR1
333:               
334:               waveform.ramp_up_time = waveform.ramp_up_pulses;
0391  3082     MOVLW 0x82
0392  0086     MOVWF FSR1
0393  3027     MOVLW 0x27
0394  0087     MOVWF FSR1H
0395  3084     MOVLW 0x84
0396  0084     MOVWF FSR0
0397  3027     MOVLW 0x27
0398  0085     MOVWF FSR0H
0399  3F40     MOVIW [0]FSR1
039A  3F80     MOVWI [0]FSR0
039B  3F41     MOVIW [1]FSR1
039C  3F81     MOVWI [1]FSR0
335:               
336:               waveform.ON_time = program.ON_time*program.frequency + waveform.ramp_up_time;    
039D  3084     MOVLW 0x84
039E  0086     MOVWF FSR1
039F  3027     MOVLW 0x27
03A0  0087     MOVWF FSR1H
03A1  0865     MOVF 0x65, W
03A2  00BC     MOVWF 0x3C
03A3  01BD     CLRF 0x3D
03A4  083C     MOVF 0x3C, W
03A5  00A0     MOVWF __pcstackBANK0
03A6  083D     MOVF 0x3D, W
03A7  00A1     MOVWF addr
03A8  0862     MOVF 0x62, W
03A9  00BE     MOVWF 0x3E
03AA  01BF     CLRF 0x3F
03AB  083E     MOVF 0x3E, W
03AC  00A2     MOVWF product
03AD  083F     MOVF 0x3F, W
03AE  00A3     MOVWF dividend
03AF  318D     MOVLP 0xD
03B0  2535     CALL 0x535
03B1  3183     MOVLP 0x3
03B2  3F40     MOVIW [0]FSR1
03B3  0720     ADDWF __pcstackBANK0, W
03B4  00C0     MOVWF 0x40
03B5  3F41     MOVIW [1]FSR1
03B6  3D21     ADDWFC addr, W
03B7  00C1     MOVWF 0x41
03B8  300D     MOVLW 0xD
03B9  0086     MOVWF FSR1
03BA  3027     MOVLW 0x27
03BB  0087     MOVWF FSR1H
03BC  314A     ADDFSR 1, 10
03BD  0840     MOVF 0x40, W
03BE  3FC0     MOVWI [0]FSR1
03BF  0841     MOVF 0x41, W
03C0  3FC1     MOVWI [1]FSR1
337:               waveform.ramp_down_time = waveform.ramp_down_pulses + waveform.ON_time;    
03C1  300D     MOVLW 0xD
03C2  0086     MOVWF FSR1
03C3  3027     MOVLW 0x27
03C4  0087     MOVWF FSR1H
03C5  314A     ADDFSR 1, 10
03C6  30EA     MOVLW 0xEA
03C7  0084     MOVWF FSR0
03C8  3027     MOVLW 0x27
03C9  0085     MOVWF FSR0H
03CA  3F40     MOVIW [0]FSR1
03CB  0700     ADDWF INDF0, W
03CC  00BC     MOVWF 0x3C
03CD  3101     ADDFSR 0, 1
03CE  3F41     MOVIW [1]FSR1
03CF  3D00     ADDWFC INDF0, W
03D0  00BD     MOVWF 0x3D
03D1  30EC     MOVLW 0xEC
03D2  0086     MOVWF FSR1
03D3  3027     MOVLW 0x27
03D4  0087     MOVWF FSR1H
03D5  083C     MOVF 0x3C, W
03D6  3FC0     MOVWI [0]FSR1
03D7  083D     MOVF 0x3D, W
03D8  3FC1     MOVWI [1]FSR1
338:               waveform.OFF_time = program.OFF_time*program.frequency + waveform.ON_time;       
03D9  300D     MOVLW 0xD
03DA  0086     MOVWF FSR1
03DB  3027     MOVLW 0x27
03DC  0087     MOVWF FSR1H
03DD  314A     ADDFSR 1, 10
03DE  0866     MOVF 0x66, W
03DF  00BC     MOVWF 0x3C
03E0  01BD     CLRF 0x3D
03E1  083C     MOVF 0x3C, W
03E2  00A0     MOVWF __pcstackBANK0
03E3  083D     MOVF 0x3D, W
03E4  00A1     MOVWF addr
03E5  0862     MOVF 0x62, W
03E6  00BE     MOVWF 0x3E
03E7  01BF     CLRF 0x3F
03E8  083E     MOVF 0x3E, W
03E9  00A2     MOVWF product
03EA  083F     MOVF 0x3F, W
03EB  00A3     MOVWF dividend
03EC  318D     MOVLP 0xD
03ED  2535     CALL 0x535
03EE  3183     MOVLP 0x3
03EF  3F40     MOVIW [0]FSR1
03F0  0720     ADDWF __pcstackBANK0, W
03F1  00C0     MOVWF 0x40
03F2  3F41     MOVIW [1]FSR1
03F3  3D21     ADDWFC addr, W
03F4  00C1     MOVWF 0x41
03F5  300D     MOVLW 0xD
03F6  0086     MOVWF FSR1
03F7  3027     MOVLW 0x27
03F8  0087     MOVWF FSR1H
03F9  314C     ADDFSR 1, 12
03FA  0840     MOVF 0x40, W
03FB  3FC0     MOVWI [0]FSR1
03FC  0841     MOVF 0x41, W
03FD  3FC1     MOVWI [1]FSR1
339:               
340:               waveform.pulse_amplitude = 0;
03FE  300D     MOVLW 0xD
03FF  0086     MOVWF FSR1
0400  3027     MOVLW 0x27
0401  0087     MOVWF FSR1H
0402  314F     ADDFSR 1, 15
0403  0181     CLRF INDF1
341:               waveform.current_amplitude = 0;
0404  300D     MOVLW 0xD
0405  0086     MOVWF FSR1
0406  3027     MOVLW 0x27
0407  0087     MOVWF FSR1H
0408  3150     ADDFSR 1, 16
0409  0181     CLRF INDF1
342:               waveform.program_amplitude = program.amplitude;
040A  301B     MOVLW 0x1B
040B  0086     MOVWF FSR1
040C  3027     MOVLW 0x27
040D  0087     MOVWF FSR1H
040E  0861     MOVF program, W
040F  0081     MOVWF INDF1
343:               
344:               waveform.silence_phase_duration = program.phase_duration + SILENCE_PERIOD;
0410  0863     MOVF 0x63, W
0411  3E01     ADDLW 0x1
0412  00BC     MOVWF 0x3C
0413  3015     MOVLW 0x15
0414  0086     MOVWF FSR1
0415  3027     MOVLW 0x27
0416  0087     MOVWF FSR1H
0417  083C     MOVF 0x3C, W
0418  0081     MOVWF INDF1
345:               waveform.minus_phase_duration = program.phase_duration*program.symmetry_factor + program.phase_duration + SILENCE_PERIOD;
0419  0864     MOVF 0x64, W
041A  00BC     MOVWF 0x3C
041B  083C     MOVF 0x3C, W
041C  00A0     MOVWF __pcstackBANK0
041D  0863     MOVF 0x63, W
041E  318C     MOVLP 0xC
041F  240A     CALL 0x40A
0420  3183     MOVLP 0x3
0421  0763     ADDWF 0x63, W
0422  3E01     ADDLW 0x1
0423  00BD     MOVWF 0x3D
0424  3016     MOVLW 0x16
0425  0086     MOVWF FSR1
0426  3027     MOVLW 0x27
0427  0087     MOVWF FSR1H
0428  083D     MOVF 0x3D, W
0429  0081     MOVWF INDF1
346:               
347:               
348:               waveform.ramp_index = 0;
042A  30EE     MOVLW 0xEE
042B  0086     MOVWF FSR1
042C  3027     MOVLW 0x27
042D  0087     MOVWF FSR1H
042E  0181     CLRF INDF1
349:               waveform.contractions_index = 0;
042F  30EF     MOVLW 0xEF
0430  0086     MOVWF FSR1
0431  3027     MOVLW 0x27
0432  0087     MOVWF FSR1H
0433  0181     CLRF INDF1
350:               
351:               NEMS_calculate_ramp();
0434  3185     MOVLP 0x5
0435  254A     CALL 0x54A
352:               
353:               NEMS_states = NEMS_DISABLED;
0436  01DF     CLRF NEMS_states
354:               NEMS_wave_states = NEMS_OFF_TIME;    
0437  3001     MOVLW 0x1
0438  00BC     MOVWF 0x3C
0439  083C     MOVF 0x3C, W
043A  00DE     MOVWF NEMS_wave_states
355:               NEMS_pulse_states = NEMS_PULSE_OFF;    
043B  01F0     CLRF NEMS_pulse_states
356:           }
043C  0008     RETURN
357:           
358:           void NEMS_calculate_ramp(void)
054A  01BB     CLRF i
359:           {
360:               unsigned char i;
361:               
362:               for (i = 0; i < waveform.ramp_up_pulses; i++) {
363:                   waveform.ramp_up_amplitude[i] = (unsigned short)(i*waveform.program_amplitude)/waveform.ramp_up_pulses;
055E  3082     MOVLW 0x82
055F  0086     MOVWF FSR1
0560  3027     MOVLW 0x27
0561  0087     MOVWF FSR1H
0562  3F40     MOVIW [0]FSR1
0563  00A6     MOVWF divisor
0564  3F41     MOVIW [1]FSR1
0565  00A7     MOVWF index
0566  083B     MOVF i, W
0567  00AE     MOVWF 0x2E
0568  01AF     CLRF val
0569  082E     MOVF 0x2E, W
056A  00A0     MOVWF __pcstackBANK0
056B  082F     MOVF val, W
056C  00A1     MOVWF addr
056D  300D     MOVLW 0xD
056E  0086     MOVWF FSR1
056F  3027     MOVLW 0x27
0570  0087     MOVWF FSR1H
0571  314E     ADDFSR 1, 14
0572  0801     MOVF INDF1, W
0573  00B0     MOVWF 0x30
0574  01B1     CLRF 0x31
0575  0830     MOVF 0x30, W
0576  00A2     MOVWF product
0577  0831     MOVF 0x31, W
0578  00A3     MOVWF dividend
0579  318D     MOVLP 0xD
057A  2535     CALL 0x535
057B  3185     MOVLP 0x5
057C  0821     MOVF addr, W
057D  00A9     MOVWF addr
057E  0820     MOVF __pcstackBANK0, W
057F  00A8     MOVWF dividend
0580  318E     MOVLP 0xE
0581  26BD     CALL 0x6BD
0582  3185     MOVLP 0x5
0583  0826     MOVF divisor, W
0584  00B2     MOVWF 0x32
0585  083B     MOVF i, W
0586  00B3     MOVWF aux
0587  01B4     CLRF buf
0588  301E     MOVLW 0x1E
0589  00B5     MOVWF 0x35
058A  3027     MOVLW 0x27
058B  00B6     MOVWF 0x36
058C  0833     MOVF aux, W
058D  0735     ADDWF 0x35, W
058E  00B7     MOVWF mess
058F  0834     MOVF buf, W
0590  3D36     ADDWFC 0x36, W
0591  00B8     MOVWF 0x38
0592  0837     MOVF mess, W
0593  0086     MOVWF FSR1
0594  0838     MOVF 0x38, W
0595  0087     MOVWF FSR1H
0596  0832     MOVF 0x32, W
0597  0081     MOVWF INDF1
364:               }
054B  3082     MOVLW 0x82
054C  0086     MOVWF FSR1
054D  3027     MOVLW 0x27
054E  0087     MOVWF FSR1H
054F  3F40     MOVIW [0]FSR1
0550  00AE     MOVWF 0x2E
0551  3F41     MOVIW [1]FSR1
0552  00AF     MOVWF val
0553  083B     MOVF i, W
0554  00B0     MOVWF 0x30
0555  01B1     CLRF 0x31
0556  082F     MOVF val, W
0557  0231     SUBWF 0x31, W
0558  1D03     BTFSS STATUS, 0x2
0559  2D5C     GOTO 0x55C
055A  082E     MOVF 0x2E, W
055B  0230     SUBWF 0x30, W
055C  1803     BTFSC STATUS, 0x0
055D  2D9D     GOTO 0x59D
0598  3001     MOVLW 0x1
0599  00AE     MOVWF 0x2E
059A  082E     MOVF 0x2E, W
059B  07BB     ADDWF i, F
059C  2D4B     GOTO 0x54B
365:               
366:               for (i = 0; i < waveform.ramp_down_pulses; i++) {
059D  01BB     CLRF i
367:                   waveform.ramp_down_amplitude[i] = (unsigned short)((waveform.ramp_down_pulses-i-1)*waveform.program_amplitude)/waveform.ramp_down_pulses;
05B1  30EA     MOVLW 0xEA
05B2  0086     MOVWF FSR1
05B3  3027     MOVLW 0x27
05B4  0087     MOVWF FSR1H
05B5  3F40     MOVIW [0]FSR1
05B6  00A6     MOVWF divisor
05B7  3F41     MOVIW [1]FSR1
05B8  00A7     MOVWF index
05B9  30EA     MOVLW 0xEA
05BA  0086     MOVWF FSR1
05BB  3027     MOVLW 0x27
05BC  0087     MOVWF FSR1H
05BD  3F40     MOVIW [0]FSR1
05BE  00AE     MOVWF 0x2E
05BF  3F41     MOVIW [1]FSR1
05C0  00AF     MOVWF val
05C1  082F     MOVF val, W
05C2  00B1     MOVWF 0x31
05C3  083B     MOVF i, W
05C4  022E     SUBWF 0x2E, W
05C5  00B0     MOVWF 0x30
05C6  1C03     BTFSS STATUS, 0x0
05C7  03B1     DECF 0x31, F
05C8  0830     MOVF 0x30, W
05C9  3EFF     ADDLW 0xFF
05CA  00A0     MOVWF __pcstackBANK0
05CB  30FF     MOVLW 0xFF
05CC  3D31     ADDWFC 0x31, W
05CD  00A1     MOVWF addr
05CE  300D     MOVLW 0xD
05CF  0086     MOVWF FSR1
05D0  3027     MOVLW 0x27
05D1  0087     MOVWF FSR1H
05D2  314E     ADDFSR 1, 14
05D3  0801     MOVF INDF1, W
05D4  00B2     MOVWF 0x32
05D5  01B3     CLRF aux
05D6  0832     MOVF 0x32, W
05D7  00A2     MOVWF product
05D8  0833     MOVF aux, W
05D9  00A3     MOVWF dividend
05DA  318D     MOVLP 0xD
05DB  2535     CALL 0x535
05DC  3185     MOVLP 0x5
05DD  0821     MOVF addr, W
05DE  00A9     MOVWF addr
05DF  0820     MOVF __pcstackBANK0, W
05E0  00A8     MOVWF dividend
05E1  318E     MOVLP 0xE
05E2  26BD     CALL 0x6BD
05E3  3185     MOVLP 0x5
05E4  0826     MOVF divisor, W
05E5  00B4     MOVWF buf
05E6  083B     MOVF i, W
05E7  00B5     MOVWF 0x35
05E8  01B6     CLRF 0x36
05E9  3086     MOVLW 0x86
05EA  00B7     MOVWF mess
05EB  3027     MOVLW 0x27
05EC  00B8     MOVWF 0x38
05ED  0835     MOVF 0x35, W
05EE  0737     ADDWF mess, W
05EF  00B9     MOVWF aux
05F0  0836     MOVF 0x36, W
05F1  3D38     ADDWFC 0x38, W
05F2  00BA     MOVWF 0x3A
05F3  0839     MOVF aux, W
05F4  0086     MOVWF FSR1
05F5  083A     MOVF 0x3A, W
05F6  0087     MOVWF FSR1H
05F7  0834     MOVF buf, W
05F8  0081     MOVWF INDF1
368:               }
059E  30EA     MOVLW 0xEA
059F  0086     MOVWF FSR1
05A0  3027     MOVLW 0x27
05A1  0087     MOVWF FSR1H
05A2  3F40     MOVIW [0]FSR1
05A3  00AE     MOVWF 0x2E
05A4  3F41     MOVIW [1]FSR1
05A5  00AF     MOVWF val
05A6  083B     MOVF i, W
05A7  00B0     MOVWF 0x30
05A8  01B1     CLRF 0x31
05A9  082F     MOVF val, W
05AA  0231     SUBWF 0x31, W
05AB  1D03     BTFSS STATUS, 0x2
05AC  2DAF     GOTO 0x5AF
05AD  082E     MOVF 0x2E, W
05AE  0230     SUBWF 0x30, W
05AF  1803     BTFSC STATUS, 0x0
05B0  0008     RETURN
05F9  3001     MOVLW 0x1
05FA  00AE     MOVWF 0x2E
05FB  082E     MOVF 0x2E, W
05FC  07BB     ADDWF i, F
05FD  2D9E     GOTO 0x59E
369:           }
370:           
371:           void NEMS_timer(void)
0046  1C7E     BTFSS 0x7E, 0x0
0047  284A     GOTO 0x4A
0048  3181     MOVLP 0x1
0049  29B6     GOTO 0x1B6
01B6  300D     MOVLW 0xD
372:           {   
373:               //UPDATE OUTPUTS
374:               DAC1_SetOutput(waveform.current_amplitude);
004A  300D     MOVLW 0xD
004B  0086     MOVWF FSR1
004C  3027     MOVLW 0x27
004D  0087     MOVWF FSR1H
004E  3150     ADDFSR 1, 16
004F  0801     MOVF INDF1, W
0050  318B     MOVLP 0xB
0051  239E     CALL 0x39E
0052  3180     MOVLP 0x0
375:               LATC = NEMS_pulse_states;
0053  0870     MOVF NEMS_pulse_states, W
0054  0140     MOVLB 0x0
0055  009A     MOVWF LATC
01BF  0870     MOVF NEMS_pulse_states, W
01C0  0140     MOVLB 0x0
01C1  009A     MOVWF LATC
376:              
377:               //PULSE STATES
378:               waveform.clock_index++;
0056  300D     MOVLW 0xD
0057  0086     MOVWF FSR1
0058  3027     MOVLW 0x27
0059  0087     MOVWF FSR1H
005A  3142     ADDFSR 1, 2
005B  3001     MOVLW 0x1
005C  0781     ADDWF INDF1, F
005D  3141     ADDFSR 1, 1
005E  1803     BTFSC STATUS, 0x0
005F  0A81     INCF INDF1, F
01C2  300D     MOVLW 0xD
01C3  0086     MOVWF FSR1
01C4  3027     MOVLW 0x27
01C5  0087     MOVWF FSR1H
01C6  3142     ADDFSR 1, 2
01C7  3001     MOVLW 0x1
01C8  0781     ADDWF INDF1, F
01C9  3141     ADDFSR 1, 1
01CA  1803     BTFSC STATUS, 0x0
01CB  0A81     INCF INDF1, F
379:                   
380:               if (waveform.clock_index >= waveform.num_clocks_per_pulse)  { //New Pulse should start 
0060  300D     MOVLW 0xD
0061  0086     MOVWF FSR1
0062  3027     MOVLW 0x27
0063  0087     MOVWF FSR1H
0064  3F40     MOVIW [0]FSR1
0065  00A1     MOVWF addr
0066  3F41     MOVIW [1]FSR1
0067  00A2     MOVWF product
0068  300D     MOVLW 0xD
0069  0086     MOVWF FSR1
006A  3027     MOVLW 0x27
006B  0087     MOVWF FSR1H
006C  3142     ADDFSR 1, 2
006D  3F40     MOVIW [0]FSR1
006E  00A3     MOVWF dividend
006F  3F41     MOVIW [1]FSR1
0070  00A4     MOVWF counter
0071  0822     MOVF product, W
0072  0224     SUBWF counter, W
0073  1D03     BTFSS STATUS, 0x2
0074  2877     GOTO 0x77
0075  0821     MOVF addr, W
0076  0223     SUBWF dividend, W
0077  1C03     BTFSS STATUS, 0x0
0078  294C     GOTO 0x14C
01CC  300D     MOVLW 0xD
01CD  0086     MOVWF FSR1
01CE  3027     MOVLW 0x27
01CF  0087     MOVWF FSR1H
01D0  3F40     MOVIW [0]FSR1
01D1  00F7     MOVWF 0x77
01D2  3F41     MOVIW [1]FSR1
01D3  00F8     MOVWF 0x78
01D4  300D     MOVLW 0xD
01D5  0086     MOVWF FSR1
01D6  3027     MOVLW 0x27
01D7  0087     MOVWF FSR1H
01D8  3142     ADDFSR 1, 2
01D9  3F40     MOVIW [0]FSR1
01DA  00F9     MOVWF 0x79
01DB  3F41     MOVIW [1]FSR1
01DC  00FA     MOVWF 0x7A
01DD  0878     MOVF 0x78, W
01DE  027A     SUBWF 0x7A, W
01DF  1D03     BTFSS STATUS, 0x2
01E0  29E3     GOTO 0x1E3
01E1  0877     MOVF 0x77, W
01E2  0279     SUBWF 0x79, W
01E3  1C03     BTFSS STATUS, 0x0
01E4  2AB8     GOTO 0x2B8
381:                   waveform.clock_index = 0;  
0079  300D     MOVLW 0xD
007A  0086     MOVWF FSR1
007B  3027     MOVLW 0x27
007C  0087     MOVWF FSR1H
007D  3142     ADDFSR 1, 2
007E  3000     MOVLW 0x0
007F  3FC0     MOVWI [0]FSR1
0080  3FC1     MOVWI [1]FSR1
01E5  300D     MOVLW 0xD
01E6  0086     MOVWF FSR1
01E7  3027     MOVLW 0x27
01E8  0087     MOVWF FSR1H
01E9  3142     ADDFSR 1, 2
01EA  3000     MOVLW 0x0
01EB  3FC0     MOVWI [0]FSR1
01EC  3FC1     MOVWI [1]FSR1
382:                   
383:                   waveform.pulse_index++;
0081  300D     MOVLW 0xD
0082  0086     MOVWF FSR1
0083  3027     MOVLW 0x27
0084  0087     MOVWF FSR1H
0085  3144     ADDFSR 1, 4
0086  3001     MOVLW 0x1
0087  0781     ADDWF INDF1, F
0088  3141     ADDFSR 1, 1
0089  1803     BTFSC STATUS, 0x0
008A  0A81     INCF INDF1, F
01ED  300D     MOVLW 0xD
01EE  0086     MOVWF FSR1
01EF  3027     MOVLW 0x27
01F0  0087     MOVWF FSR1H
01F1  3144     ADDFSR 1, 4
01F2  3001     MOVLW 0x1
01F3  0781     ADDWF INDF1, F
01F4  3141     ADDFSR 1, 1
01F5  1803     BTFSC STATUS, 0x0
01F6  0A81     INCF INDF1, F
384:                   
385:                   NEMS_pulse_states = NEMS_PLUS_UP;
008B  3002     MOVLW 0x2
008C  00A1     MOVWF addr
008D  0821     MOVF addr, W
008E  00F0     MOVWF NEMS_pulse_states
01F7  3002     MOVLW 0x2
01F8  00F7     MOVWF 0x77
01F9  0877     MOVF 0x77, W
01FA  00F0     MOVWF NEMS_pulse_states
386:               
387:                   if (waveform.pulse_index < waveform.ramp_up_time) {
008F  3084     MOVLW 0x84
0090  0086     MOVWF FSR1
0091  3027     MOVLW 0x27
0092  0087     MOVWF FSR1H
0093  3F40     MOVIW [0]FSR1
0094  00A1     MOVWF addr
0095  3F41     MOVIW [1]FSR1
0096  00A2     MOVWF product
0097  300D     MOVLW 0xD
0098  0086     MOVWF FSR1
0099  3027     MOVLW 0x27
009A  0087     MOVWF FSR1H
009B  3144     ADDFSR 1, 4
009C  3F40     MOVIW [0]FSR1
009D  00A3     MOVWF dividend
009E  3F41     MOVIW [1]FSR1
009F  00A4     MOVWF counter
00A0  0822     MOVF product, W
00A1  0224     SUBWF counter, W
00A2  1D03     BTFSS STATUS, 0x2
00A3  28A6     GOTO 0xA6
00A4  0821     MOVF addr, W
00A5  0223     SUBWF dividend, W
00A6  1803     BTFSC STATUS, 0x0
00A7  28BF     GOTO 0xBF
01FB  3084     MOVLW 0x84
01FC  0086     MOVWF FSR1
01FD  3027     MOVLW 0x27
01FE  0087     MOVWF FSR1H
01FF  3F40     MOVIW [0]FSR1
0200  00F7     MOVWF 0x77
0201  3F41     MOVIW [1]FSR1
0202  00F8     MOVWF 0x78
0203  300D     MOVLW 0xD
0204  0086     MOVWF FSR1
0205  3027     MOVLW 0x27
0206  0087     MOVWF FSR1H
0207  3144     ADDFSR 1, 4
0208  3F40     MOVIW [0]FSR1
0209  00F9     MOVWF 0x79
020A  3F41     MOVIW [1]FSR1
020B  00FA     MOVWF 0x7A
020C  0878     MOVF 0x78, W
020D  027A     SUBWF 0x7A, W
020E  1D03     BTFSS STATUS, 0x2
020F  2A12     GOTO 0x212
0210  0877     MOVF 0x77, W
0211  0279     SUBWF 0x79, W
0212  1803     BTFSC STATUS, 0x0
0213  2A2B     GOTO 0x22B
388:                       waveform.pulse_amplitude = waveform.ramp_up_amplitude[waveform.pulse_index];
00A8  300D     MOVLW 0xD
00A9  0086     MOVWF FSR1
00AA  3027     MOVLW 0x27
00AB  0087     MOVWF FSR1H
00AC  3144     ADDFSR 1, 4
00AD  301E     MOVLW 0x1E
00AE  00A1     MOVWF addr
00AF  3027     MOVLW 0x27
00B0  00A2     MOVWF product
00B1  3F40     MOVIW [0]FSR1
00B2  0721     ADDWF addr, W
00B3  0084     MOVWF FSR0
00B4  3F41     MOVIW [1]FSR1
00B5  3D22     ADDWFC product, W
00B6  0085     MOVWF FSR0H
00B7  0800     MOVF INDF0, W
00B8  00A3     MOVWF dividend
00B9  301C     MOVLW 0x1C
00BA  0086     MOVWF FSR1
00BB  3027     MOVLW 0x27
00BC  0087     MOVWF FSR1H
00BD  0823     MOVF dividend, W
00BE  2920     GOTO 0x120
0214  300D     MOVLW 0xD
0215  0086     MOVWF FSR1
0216  3027     MOVLW 0x27
0217  0087     MOVWF FSR1H
0218  3144     ADDFSR 1, 4
0219  301E     MOVLW 0x1E
021A  00F7     MOVWF 0x77
021B  3027     MOVLW 0x27
021C  00F8     MOVWF 0x78
021D  3F40     MOVIW [0]FSR1
021E  0777     ADDWF 0x77, W
021F  0084     MOVWF FSR0
0220  3F41     MOVIW [1]FSR1
0221  3D78     ADDWFC 0x78, W
0222  0085     MOVWF FSR0H
0223  0800     MOVF INDF0, W
0224  00F9     MOVWF 0x79
0225  301C     MOVLW 0x1C
0226  0086     MOVWF FSR1
0227  3027     MOVLW 0x27
0228  0087     MOVWF FSR1H
0229  0879     MOVF 0x79, W
022A  2A8C     GOTO 0x28C
389:                               
390:                   } else if (waveform.pulse_index < waveform.ON_time) {
00BF  300D     MOVLW 0xD
00C0  0086     MOVWF FSR1
00C1  3027     MOVLW 0x27
00C2  0087     MOVWF FSR1H
00C3  314A     ADDFSR 1, 10
00C4  3F40     MOVIW [0]FSR1
00C5  00A1     MOVWF addr
00C6  3F41     MOVIW [1]FSR1
00C7  00A2     MOVWF product
00C8  300D     MOVLW 0xD
00C9  0086     MOVWF FSR1
00CA  3027     MOVLW 0x27
00CB  0087     MOVWF FSR1H
00CC  3144     ADDFSR 1, 4
00CD  3F40     MOVIW [0]FSR1
00CE  00A3     MOVWF dividend
00CF  3F41     MOVIW [1]FSR1
00D0  00A4     MOVWF counter
00D1  0822     MOVF product, W
00D2  0224     SUBWF counter, W
00D3  1D03     BTFSS STATUS, 0x2
00D4  28D7     GOTO 0xD7
00D5  0821     MOVF addr, W
00D6  0223     SUBWF dividend, W
00D7  1803     BTFSC STATUS, 0x0
00D8  28E6     GOTO 0xE6
022B  300D     MOVLW 0xD
022C  0086     MOVWF FSR1
022D  3027     MOVLW 0x27
022E  0087     MOVWF FSR1H
022F  314A     ADDFSR 1, 10
0230  3F40     MOVIW [0]FSR1
0231  00F7     MOVWF 0x77
0232  3F41     MOVIW [1]FSR1
0233  00F8     MOVWF 0x78
0234  300D     MOVLW 0xD
0235  0086     MOVWF FSR1
0236  3027     MOVLW 0x27
0237  0087     MOVWF FSR1H
0238  3144     ADDFSR 1, 4
0239  3F40     MOVIW [0]FSR1
023A  00F9     MOVWF 0x79
023B  3F41     MOVIW [1]FSR1
023C  00FA     MOVWF 0x7A
023D  0878     MOVF 0x78, W
023E  027A     SUBWF 0x7A, W
023F  1D03     BTFSS STATUS, 0x2
0240  2A43     GOTO 0x243
0241  0877     MOVF 0x77, W
0242  0279     SUBWF 0x79, W
0243  1803     BTFSC STATUS, 0x0
0244  2A52     GOTO 0x252
391:                       waveform.pulse_amplitude = waveform.program_amplitude;
00D9  300D     MOVLW 0xD
00DA  0086     MOVWF FSR1
00DB  3027     MOVLW 0x27
00DC  0087     MOVWF FSR1H
00DD  314E     ADDFSR 1, 14
00DE  0801     MOVF INDF1, W
00DF  00A1     MOVWF addr
00E0  301C     MOVLW 0x1C
00E1  0086     MOVWF FSR1
00E2  3027     MOVLW 0x27
00E3  0087     MOVWF FSR1H
00E4  0821     MOVF addr, W
00E5  2920     GOTO 0x120
0245  300D     MOVLW 0xD
0246  0086     MOVWF FSR1
0247  3027     MOVLW 0x27
0248  0087     MOVWF FSR1H
0249  314E     ADDFSR 1, 14
024A  0801     MOVF INDF1, W
024B  00F7     MOVWF 0x77
024C  301C     MOVLW 0x1C
024D  0086     MOVWF FSR1
024E  3027     MOVLW 0x27
024F  0087     MOVWF FSR1H
0250  0877     MOVF 0x77, W
0251  2A8C     GOTO 0x28C
392:                               
393:                   } else if (waveform.pulse_index < waveform.ramp_down_time) {
00E6  30EC     MOVLW 0xEC
00E7  0086     MOVWF FSR1
00E8  3027     MOVLW 0x27
00E9  0087     MOVWF FSR1H
00EA  3F40     MOVIW [0]FSR1
00EB  00A1     MOVWF addr
00EC  3F41     MOVIW [1]FSR1
00ED  00A2     MOVWF product
00EE  300D     MOVLW 0xD
00EF  0086     MOVWF FSR1
00F0  3027     MOVLW 0x27
00F1  0087     MOVWF FSR1H
00F2  3144     ADDFSR 1, 4
00F3  3F40     MOVIW [0]FSR1
00F4  00A3     MOVWF dividend
00F5  3F41     MOVIW [1]FSR1
00F6  00A4     MOVWF counter
00F7  0822     MOVF product, W
00F8  0224     SUBWF counter, W
00F9  1D03     BTFSS STATUS, 0x2
00FA  28FD     GOTO 0xFD
00FB  0821     MOVF addr, W
00FC  0223     SUBWF dividend, W
00FD  1803     BTFSC STATUS, 0x0
00FE  2922     GOTO 0x122
0252  30EC     MOVLW 0xEC
0253  0086     MOVWF FSR1
0254  3027     MOVLW 0x27
0255  0087     MOVWF FSR1H
0256  3F40     MOVIW [0]FSR1
0257  00F7     MOVWF 0x77
0258  3F41     MOVIW [1]FSR1
0259  00F8     MOVWF 0x78
025A  300D     MOVLW 0xD
025B  0086     MOVWF FSR1
025C  3027     MOVLW 0x27
025D  0087     MOVWF FSR1H
025E  3144     ADDFSR 1, 4
025F  3F40     MOVIW [0]FSR1
0260  00F9     MOVWF 0x79
0261  3F41     MOVIW [1]FSR1
0262  00FA     MOVWF 0x7A
0263  0878     MOVF 0x78, W
0264  027A     SUBWF 0x7A, W
0265  1D03     BTFSS STATUS, 0x2
0266  2A69     GOTO 0x269
0267  0877     MOVF 0x77, W
0268  0279     SUBWF 0x79, W
0269  1803     BTFSC STATUS, 0x0
026A  2A8E     GOTO 0x28E
394:                       waveform.pulse_amplitude = waveform.ramp_down_amplitude[waveform.pulse_index - waveform.ON_time];
00FF  300D     MOVLW 0xD
0100  0086     MOVWF FSR1
0101  3027     MOVLW 0x27
0102  0087     MOVWF FSR1H
0103  3144     ADDFSR 1, 4
0104  300D     MOVLW 0xD
0105  0084     MOVWF FSR0
0106  3027     MOVLW 0x27
0107  0085     MOVWF FSR0H
0108  310A     ADDFSR 0, 10
0109  3086     MOVLW 0x86
010A  00A1     MOVWF addr
010B  3027     MOVLW 0x27
010C  00A2     MOVWF product
010D  3F00     MOVIW [0]FSR0
010E  0221     SUBWF addr, W
010F  00A3     MOVWF dividend
0110  3F01     MOVIW [1]FSR0
0111  3B22     SUBWFB product, W
0112  00A4     MOVWF counter
0113  3F40     MOVIW [0]FSR1
0114  0723     ADDWF dividend, W
0115  0084     MOVWF FSR0
0116  3F41     MOVIW [1]FSR1
0117  3D24     ADDWFC counter, W
0118  0085     MOVWF FSR0H
0119  0800     MOVF INDF0, W
011A  00A5     MOVWF rem
011B  301C     MOVLW 0x1C
011C  0086     MOVWF FSR1
011D  3027     MOVLW 0x27
011E  0087     MOVWF FSR1H
011F  0825     MOVF rem, W
0120  0081     MOVWF INDF1
026B  300D     MOVLW 0xD
026C  0086     MOVWF FSR1
026D  3027     MOVLW 0x27
026E  0087     MOVWF FSR1H
026F  3144     ADDFSR 1, 4
0270  300D     MOVLW 0xD
0271  0084     MOVWF FSR0
0272  3027     MOVLW 0x27
0273  0085     MOVWF FSR0H
0274  310A     ADDFSR 0, 10
0275  3086     MOVLW 0x86
0276  00F7     MOVWF 0x77
0277  3027     MOVLW 0x27
0278  00F8     MOVWF 0x78
0279  3F00     MOVIW [0]FSR0
027A  0277     SUBWF 0x77, W
027B  00F9     MOVWF 0x79
027C  3F01     MOVIW [1]FSR0
027D  3B78     SUBWFB 0x78, W
027E  00FA     MOVWF 0x7A
027F  3F40     MOVIW [0]FSR1
0280  0779     ADDWF 0x79, W
0281  0084     MOVWF FSR0
0282  3F41     MOVIW [1]FSR1
0283  3D7A     ADDWFC 0x7A, W
0284  0085     MOVWF FSR0H
0285  0800     MOVF INDF0, W
0286  00FB     MOVWF 0x7B
0287  301C     MOVLW 0x1C
0288  0086     MOVWF FSR1
0289  3027     MOVLW 0x27
028A  0087     MOVWF FSR1H
028B  087B     MOVF 0x7B, W
028C  0081     MOVWF INDF1
395:                   
396:                   } else if (waveform.pulse_index < waveform.OFF_time) {
0121  294C     GOTO 0x14C
0122  300D     MOVLW 0xD
0123  0086     MOVWF FSR1
0124  3027     MOVLW 0x27
0125  0087     MOVWF FSR1H
0126  314C     ADDFSR 1, 12
0127  3F40     MOVIW [0]FSR1
0128  00A1     MOVWF addr
0129  3F41     MOVIW [1]FSR1
012A  00A2     MOVWF product
012B  300D     MOVLW 0xD
012C  0086     MOVWF FSR1
012D  3027     MOVLW 0x27
012E  0087     MOVWF FSR1H
012F  3144     ADDFSR 1, 4
0130  3F40     MOVIW [0]FSR1
0131  00A3     MOVWF dividend
0132  3F41     MOVIW [1]FSR1
0133  00A4     MOVWF counter
0134  0822     MOVF product, W
0135  0224     SUBWF counter, W
0136  1D03     BTFSS STATUS, 0x2
0137  293A     GOTO 0x13A
0138  0821     MOVF addr, W
0139  0223     SUBWF dividend, W
013A  1803     BTFSC STATUS, 0x0
013B  2944     GOTO 0x144
028D  2AB8     GOTO 0x2B8
028E  300D     MOVLW 0xD
028F  0086     MOVWF FSR1
0290  3027     MOVLW 0x27
0291  0087     MOVWF FSR1H
0292  314C     ADDFSR 1, 12
0293  3F40     MOVIW [0]FSR1
0294  00F7     MOVWF 0x77
0295  3F41     MOVIW [1]FSR1
0296  00F8     MOVWF 0x78
0297  300D     MOVLW 0xD
0298  0086     MOVWF FSR1
0299  3027     MOVLW 0x27
029A  0087     MOVWF FSR1H
029B  3144     ADDFSR 1, 4
029C  3F40     MOVIW [0]FSR1
029D  00F9     MOVWF 0x79
029E  3F41     MOVIW [1]FSR1
029F  00FA     MOVWF 0x7A
02A0  0878     MOVF 0x78, W
02A1  027A     SUBWF 0x7A, W
02A2  1D03     BTFSS STATUS, 0x2
02A3  2AA6     GOTO 0x2A6
02A4  0877     MOVF 0x77, W
02A5  0279     SUBWF 0x79, W
02A6  1803     BTFSC STATUS, 0x0
02A7  2AB0     GOTO 0x2B0
397:                       waveform.pulse_amplitude = 0;
013C  300D     MOVLW 0xD
013D  0086     MOVWF FSR1
013E  3027     MOVLW 0x27
013F  0087     MOVWF FSR1H
0140  314F     ADDFSR 1, 15
0141  0181     CLRF INDF1
02A8  300D     MOVLW 0xD
02A9  0086     MOVWF FSR1
02AA  3027     MOVLW 0x27
02AB  0087     MOVWF FSR1H
02AC  314F     ADDFSR 1, 15
02AD  0181     CLRF INDF1
398:                       NEMS_pulse_states = NEMS_PULSE_OFF;
0142  01F0     CLRF NEMS_pulse_states
02AE  01F0     CLRF NEMS_pulse_states
399:                   
400:                   } else { //single repetition finished
0143  294C     GOTO 0x14C
02AF  2AB8     GOTO 0x2B8
401:                       waveform.pulse_index = 0;        
0144  300D     MOVLW 0xD
0145  0086     MOVWF FSR1
0146  3027     MOVLW 0x27
0147  0087     MOVWF FSR1H
0148  3144     ADDFSR 1, 4
0149  3000     MOVLW 0x0
014A  3FC0     MOVWI [0]FSR1
014B  3FC1     MOVWI [1]FSR1
02B0  300D     MOVLW 0xD
02B1  0086     MOVWF FSR1
02B2  3027     MOVLW 0x27
02B3  0087     MOVWF FSR1H
02B4  3144     ADDFSR 1, 4
02B5  3000     MOVLW 0x0
02B6  3FC0     MOVWI [0]FSR1
02B7  3FC1     MOVWI [1]FSR1
402:                   }
403:                   
404:               }
405:               
406:               if (NEMS_pulse_states != NEMS_PULSE_OFF) {
014C  0870     MOVF NEMS_pulse_states, W
014D  1903     BTFSC STATUS, 0x2
014E  0008     RETURN
02B8  0870     MOVF NEMS_pulse_states, W
02B9  1903     BTFSC STATUS, 0x2
02BA  0008     RETURN
407:                   if (waveform.clock_index < program.phase_duration) {               
014F  0863     MOVF 0x63, W
0150  00A1     MOVWF addr
0151  01A2     CLRF product
0152  300D     MOVLW 0xD
0153  0086     MOVWF FSR1
0154  3027     MOVLW 0x27
0155  0087     MOVWF FSR1H
0156  3142     ADDFSR 1, 2
0157  3F40     MOVIW [0]FSR1
0158  00A3     MOVWF dividend
0159  3F41     MOVIW [1]FSR1
015A  00A4     MOVWF counter
015B  0822     MOVF product, W
015C  0224     SUBWF counter, W
015D  1D03     BTFSS STATUS, 0x2
015E  2961     GOTO 0x161
015F  0821     MOVF addr, W
0160  0223     SUBWF dividend, W
0161  1803     BTFSC STATUS, 0x0
0162  2975     GOTO 0x175
02BB  0863     MOVF 0x63, W
02BC  00F7     MOVWF 0x77
02BD  01F8     CLRF 0x78
02BE  300D     MOVLW 0xD
02BF  0086     MOVWF FSR1
02C0  3027     MOVLW 0x27
02C1  0087     MOVWF FSR1H
02C2  3142     ADDFSR 1, 2
02C3  3F40     MOVIW [0]FSR1
02C4  00F9     MOVWF 0x79
02C5  3F41     MOVIW [1]FSR1
02C6  00FA     MOVWF 0x7A
02C7  0878     MOVF 0x78, W
02C8  027A     SUBWF 0x7A, W
02C9  1D03     BTFSS STATUS, 0x2
02CA  2ACD     GOTO 0x2CD
02CB  0877     MOVF 0x77, W
02CC  0279     SUBWF 0x79, W
02CD  1803     BTFSC STATUS, 0x0
02CE  2AE1     GOTO 0x2E1
408:                       NEMS_pulse_states = NEMS_PLUS_UP;
0163  3002     MOVLW 0x2
0164  00A1     MOVWF addr
0165  0821     MOVF addr, W
0166  00F0     MOVWF NEMS_pulse_states
02CF  3002     MOVLW 0x2
02D0  00F7     MOVWF 0x77
02D1  0877     MOVF 0x77, W
02D2  00F0     MOVWF NEMS_pulse_states
409:                       waveform.current_amplitude = waveform.pulse_amplitude;
0167  300D     MOVLW 0xD
0168  0086     MOVWF FSR1
0169  3027     MOVLW 0x27
016A  0087     MOVWF FSR1H
016B  314F     ADDFSR 1, 15
016C  0801     MOVF INDF1, W
016D  00A1     MOVWF addr
016E  301D     MOVLW 0x1D
016F  0086     MOVWF FSR1
0170  3027     MOVLW 0x27
0171  0087     MOVWF FSR1H
0172  0821     MOVF addr, W
0173  0081     MOVWF INDF1
02D3  300D     MOVLW 0xD
02D4  0086     MOVWF FSR1
02D5  3027     MOVLW 0x27
02D6  0087     MOVWF FSR1H
02D7  314F     ADDFSR 1, 15
02D8  0801     MOVF INDF1, W
02D9  00F7     MOVWF 0x77
02DA  301D     MOVLW 0x1D
02DB  0086     MOVWF FSR1
02DC  3027     MOVLW 0x27
02DD  0087     MOVWF FSR1H
02DE  0877     MOVF 0x77, W
02DF  0081     MOVWF INDF1
410:                       
411:                   }  else if (waveform.clock_index < waveform.silence_phase_duration) {
0174  0008     RETURN
0175  300D     MOVLW 0xD
0176  0086     MOVWF FSR1
0177  3027     MOVLW 0x27
0178  0087     MOVWF FSR1H
0179  3148     ADDFSR 1, 8
017A  0801     MOVF INDF1, W
017B  00A1     MOVWF addr
017C  01A2     CLRF product
017D  300D     MOVLW 0xD
017E  0086     MOVWF FSR1
017F  3027     MOVLW 0x27
0180  0087     MOVWF FSR1H
0181  3142     ADDFSR 1, 2
0182  3F40     MOVIW [0]FSR1
0183  00A3     MOVWF dividend
0184  3F41     MOVIW [1]FSR1
0185  00A4     MOVWF counter
0186  0822     MOVF product, W
0187  0224     SUBWF counter, W
0188  1D03     BTFSS STATUS, 0x2
0189  298C     GOTO 0x18C
018A  0821     MOVF addr, W
018B  0223     SUBWF dividend, W
018C  1803     BTFSC STATUS, 0x0
018D  2999     GOTO 0x199
02E0  0008     RETURN
02E1  300D     MOVLW 0xD
02E2  0086     MOVWF FSR1
02E3  3027     MOVLW 0x27
02E4  0087     MOVWF FSR1H
02E5  3148     ADDFSR 1, 8
02E6  0801     MOVF INDF1, W
02E7  00F7     MOVWF 0x77
02E8  01F8     CLRF 0x78
02E9  300D     MOVLW 0xD
02EA  0086     MOVWF FSR1
02EB  3027     MOVLW 0x27
02EC  0087     MOVWF FSR1H
02ED  3142     ADDFSR 1, 2
02EE  3F40     MOVIW [0]FSR1
02EF  00F9     MOVWF 0x79
02F0  3F41     MOVIW [1]FSR1
02F1  00FA     MOVWF 0x7A
02F2  0878     MOVF 0x78, W
02F3  027A     SUBWF 0x7A, W
02F4  1D03     BTFSS STATUS, 0x2
02F5  2AF8     GOTO 0x2F8
02F6  0877     MOVF 0x77, W
02F7  0279     SUBWF 0x79, W
02F8  1803     BTFSC STATUS, 0x0
02F9  2B05     GOTO 0x305
412:                       NEMS_pulse_states = NEMS_REST;
018E  3001     MOVLW 0x1
018F  00A1     MOVWF addr
0190  0821     MOVF addr, W
0191  00F0     MOVWF NEMS_pulse_states
02FA  3001     MOVLW 0x1
02FB  00F7     MOVWF 0x77
02FC  0877     MOVF 0x77, W
02FD  00F0     MOVWF NEMS_pulse_states
413:                       waveform.current_amplitude = 0;
0192  300D     MOVLW 0xD
0193  0086     MOVWF FSR1
0194  3027     MOVLW 0x27
0195  0087     MOVWF FSR1H
0196  3150     ADDFSR 1, 16
0197  0181     CLRF INDF1
02FE  300D     MOVLW 0xD
02FF  0086     MOVWF FSR1
0300  3027     MOVLW 0x27
0301  0087     MOVWF FSR1H
0302  3150     ADDFSR 1, 16
0303  0181     CLRF INDF1
414:                       
415:                   } else if (waveform.clock_index < waveform.minus_phase_duration) {
0198  0008     RETURN
0199  300D     MOVLW 0xD
019A  0086     MOVWF FSR1
019B  3027     MOVLW 0x27
019C  0087     MOVWF FSR1H
019D  3149     ADDFSR 1, 9
019E  0801     MOVF INDF1, W
019F  00A1     MOVWF addr
01A0  01A2     CLRF product
01A1  300D     MOVLW 0xD
01A2  0086     MOVWF FSR1
01A3  3027     MOVLW 0x27
01A4  0087     MOVWF FSR1H
01A5  3142     ADDFSR 1, 2
01A6  3F40     MOVIW [0]FSR1
01A7  00A3     MOVWF dividend
01A8  3F41     MOVIW [1]FSR1
01A9  00A4     MOVWF counter
01AA  0822     MOVF product, W
01AB  0224     SUBWF counter, W
01AC  1D03     BTFSS STATUS, 0x2
01AD  29B0     GOTO 0x1B0
01AE  0821     MOVF addr, W
01AF  0223     SUBWF dividend, W
01B0  1803     BTFSC STATUS, 0x0
01B1  29B4     GOTO 0x1B4
0304  0008     RETURN
0305  300D     MOVLW 0xD
0306  0086     MOVWF FSR1
0307  3027     MOVLW 0x27
0308  0087     MOVWF FSR1H
0309  3149     ADDFSR 1, 9
030A  0801     MOVF INDF1, W
030B  00F7     MOVWF 0x77
030C  01F8     CLRF 0x78
030D  300D     MOVLW 0xD
030E  0086     MOVWF FSR1
030F  3027     MOVLW 0x27
0310  0087     MOVWF FSR1H
0311  3142     ADDFSR 1, 2
0312  3F40     MOVIW [0]FSR1
0313  00F9     MOVWF 0x79
0314  3F41     MOVIW [1]FSR1
0315  00FA     MOVWF 0x7A
0316  0878     MOVF 0x78, W
0317  027A     SUBWF 0x7A, W
0318  1D03     BTFSS STATUS, 0x2
0319  2B1C     GOTO 0x31C
031A  0877     MOVF 0x77, W
031B  0279     SUBWF 0x79, W
031C  1803     BTFSC STATUS, 0x0
031D  2B20     GOTO 0x320
416:                       NEMS_pulse_states = NEMS_MINUS_UP;
01B2  3004     MOVLW 0x4
01B3  2964     GOTO 0x164
031E  3004     MOVLW 0x4
031F  2AD0     GOTO 0x2D0
417:                       waveform.current_amplitude = waveform.pulse_amplitude;
418:                       
419:                   } else {
420:                       NEMS_pulse_states = NEMS_PULSE_OFF;
01B4  01F0     CLRF NEMS_pulse_states
01B5  2992     GOTO 0x192
0320  01F0     CLRF NEMS_pulse_states
0321  2AFE     GOTO 0x2FE
421:                       waveform.current_amplitude = 0;
422:                   }
423:               }
424:                     
425:           }
426:           
427:           void NEMS_start_program()
0C2C  3183     MOVLP 0x3
0C2D  2322     CALL 0x322
0C2E  318C     MOVLP 0xC
428:           {
429:               NEMS_recalculate_program();
430:               
431:               NEMS_states = NEMS_ENABLED;
0C2F  3001     MOVLW 0x1
0C30  00C2     MOVWF 0x42
0C31  0842     MOVF 0x42, W
0C32  00DF     MOVWF NEMS_states
432:               TMR0_StartTimer();
0C33  318B     MOVLP 0xB
0C34  2384     CALL 0x384
0C35  318C     MOVLP 0xC
433:               
434:               _puts("n-ok ");
0C36  3035     MOVLW 0x35
0C37  0140     MOVLB 0x0
0C38  00A2     MOVWF product
0C39  3091     MOVLW 0x91
0C3A  00A3     MOVWF dividend
0C3B  318E     MOVLP 0xE
0C3C  262E     CALL 0x62E
435:           }
0C3D  0008     RETURN
436:           
437:           void NEMS_stop_program()
0C1B  0140     MOVLB 0x0
0C1C  01DF     CLRF NEMS_states
438:           {
439:               NEMS_states = NEMS_DISABLED;    
440:               TMR0_StopTimer();   
0C1D  318B     MOVLP 0xB
0C1E  2381     CALL 0x381
0C1F  318C     MOVLP 0xC
441:               DAC1_SetOutput(0);
0C20  3000     MOVLW 0x0
0C21  318B     MOVLP 0xB
0C22  239E     CALL 0x39E
0C23  318C     MOVLP 0xC
442:               
443:               _puts("N-ok ");
0C24  30FF     MOVLW 0xFF
0C25  0140     MOVLB 0x0
0C26  00A2     MOVWF product
0C27  3090     MOVLW 0x90
0C28  00A3     MOVWF dividend
0C29  318E     MOVLP 0xE
0C2A  262E     CALL 0x62E
444:           }
0C2B  0008     RETURN
